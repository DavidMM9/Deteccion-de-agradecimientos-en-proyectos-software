<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Assertion-based slicing and slice graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher>Association for Computing Machinery (ACM)</publisher>
				<availability status="unknown"><p>Copyright Association for Computing Machinery (ACM)</p>
				</availability>
				<date type="published" when="2011-09-23">23 September 2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">José</forename><forename type="middle">Bernardo</forename><surname>Barros</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Departamento de Informática/CCTC</orgName>
								<orgName type="institution">Universidade do Minho</orgName>
								<address>
									<addrLine>Campus de Gualtar</addrLine>
									<postCode>4710-057</postCode>
									<settlement>Braga</settlement>
									<country key="PT">Portugal</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName><forename type="first">Daniela</forename><surname>Da Cruz</surname></persName>
							<email>danieladacruz@di.uminho.pt</email>
							<affiliation key="aff0">
								<orgName type="department">Departamento de Informática/CCTC</orgName>
								<orgName type="institution">Universidade do Minho</orgName>
								<address>
									<addrLine>Campus de Gualtar</addrLine>
									<postCode>4710-057</postCode>
									<settlement>Braga</settlement>
									<country key="PT">Portugal</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Pedro</forename><forename type="middle">Rangel</forename><surname>Henriques</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Departamento de Informática/CCTC</orgName>
								<orgName type="institution">Universidade do Minho</orgName>
								<address>
									<addrLine>Campus de Gualtar</addrLine>
									<postCode>4710-057</postCode>
									<settlement>Braga</settlement>
									<country key="PT">Portugal</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Jorge</forename><forename type="middle">Sousa</forename><surname>Pinto</surname></persName>
						</author>
						<title level="a" type="main">Assertion-based slicing and slice graphs</title>
					</analytic>
					<monogr>
						<title level="j" type="main">Formal Aspects of Computing</title>
						<title level="j" type="abbrev">Form. Asp. Comput.</title>
						<idno type="ISSN">0934-5043</idno>
						<idno type="eISSN">1433-299X</idno>
						<imprint>
							<publisher>Association for Computing Machinery (ACM)</publisher>
							<biblScope unit="volume">24</biblScope>
							<biblScope unit="issue">2</biblScope>
							<biblScope unit="page" from="217" to="248"/>
							<date type="published" when="2011-09-23">23 September 2011</date>
						</imprint>
					</monogr>
					<idno type="MD5">14AD82C514982FF47721620737D9BBA5</idno>
					<idno type="DOI">10.1007/s00165-011-0196-1</idno>
					<note type="submission">Received 18 January 2011 Revised 20 June 2011 Accepted 22 July 2011 by José Fiadero, Stefania Gnesi and Tom Maibaum</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-21T19:38+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Program slicing</term>
					<term>Program analysis</term>
					<term>Verification conditions</term>
					<term>Control flow graphs</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This paper revisits the idea of slicing programs based on their axiomatic semantics, rather than using criteria based on control/data dependencies. We show how the forward propagation of preconditions and the backward propagation of postconditions can be combined in a new slicing algorithm that is more precise than the existing specification-based algorithms. The algorithm is based on (a) a precise test for removable statements, and (b) the construction of a slice graph, a program control flow graph extended with semantic labels and additional edges that "short-circuit" removable commands. It improves on previous approaches in two aspects: it does not fail to identify removable commands; and it produces the smallest possible slice that can be obtained (in a sense that will be made precise). Iteration is handled through the use of loop invariants and variants to ensure termination. The paper also discusses in detail applications of these forms of slicing, including the elimination of (conditionally) unreachable and dead code, and compares them to other related notions.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>Program slicing <ref type="bibr" target="#b18">[Wei81]</ref> is a well-established activity in software engineering. It plays an important role in program comprehension, since it allows software engineers to focus on the relevant portions of code (with respect to a given criterion). The basic idea is to isolate a subset of program statements that • either directly or indirectly contribute to the values of a set of variables at a given program location, or • are influenced by the values of a given set of variables.</p><p>Other statements are considered extraneous with respect to the given criterion and can be removed, enabling engineers to concentrate on the analysis of just the relevant ones. The first approach corresponds to backward forms of slicing, whereas the second corresponds to forward slicing.</p><p>Correspondence and offprint requests to: J. S. Pinto, E-mail: jsp@di.uminho.pt may overlap, so this is not a trivial problem. We solve it by introducing a notion of slice graph, which contains as subgraphs the control flow graph of every slice of the program. This allows us to define a slicing algorithm that can be applied to calculate precondition-, postcondition-, and specification-based slices, but we concentrate on the latter, since the first two are particular cases.</p><p>We claim that our algorithm produces minimal slices. Note that the algorithm is optimal in a relative sense, since the test for removable subprograms involves first-order formulas whose validity must be established externally by some proof tool. Undecidability of first-order logic destroys any hope of being able to identify every removable subprogram automatically, since some valid formulas may not be proved.</p><p>This paper extends <ref type="bibr" target="#b4">[BdCHP10]</ref> in a number of ways. An appropriate treatment of loops is given, and a new notion of termination-sensitive slicing is introduced. More examples have been added, and proofs, related work, slicing algorithms, and applications (in particular in the elimination of redundant code) are discussed in much more detail.</p><p>Structure of the paper Section 2 introduces the simple language considered in the paper, and the definitions of verification conditions, both based on weak precondition and strong postcondition calculations. In Sect. 3 we review the previous work in this area, including a discussion of aspects of the extant algorithms regarding their precision and minimality of the calculated slices. Section 4 then discusses in detail applications of assertion-based slicing, illustrated by a number of examples. Sections 5, 6 and 7 contain the main technical contributions of the paper: we first study properties of specification-based slicing and propose a precise test for identifying removable blocks of code, as well as a principle for slicing subprograms of a program. Later we introduce the setting for a graph-based algorithm that computes minimal slices of a program with respect to a given specification. We conclude the paper in Sect. 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Foundations</head><p>A simple imperative language We will illustrate our ideas with programs of a core imperative language. Its syntax is given in Fig. <ref type="figure" target="#fig_0">1</ref> (the remaining contents of the figure are explained below). Programs are non-empty sequences of commands. Commands may in turn (in the case of conditional and loop) contain subprograms. We omit here the operational semantics of the language, and give instead an axiomatic semantics in the form of a Verification Conditions Generator (VCGen), which will now be explained.</p><p>We remark that the choice of language is not important; the only crucial requirements are the existence of an axiomatic semantics, and the availability of a proof tool capable of reasoning about the data structures that are present in the language. The difficulties involved in extending the ideas presented here to realistic languages (for instance languages with pointers and dynamic data structures) have to do with the treatment of verification conditions only.</p><p>Weakest preconditions and strongest postconditions One way to obtain a verification condition for a program S (i.e. a formula whose validity implies the partial correctness<ref type="foot" target="#foot_0">1</ref> of S with respect to a specification consisting of precondition P and postcondition Q) is to use Dijkstra's weakest liberal precondition <ref type="bibr" target="#b11">[Dij76]</ref> predicate transformer: wlp.S .Q designates the weakest precondition that will lead to Q being true in the final state, if the execution of S terminates. The verification condition for S to meet its specification can then be written as P → wlp.S .Q. In this paper we assume that every loop is annotated with a user-provided invariant; in the presence of a loop invariant, the different required conditions (the invariant is initially true, it is preserved by loop iterations, and together with the condition for exiting the loop it is stronger that the desired postcondition) are combined in a single formula to give a possible precondition of each loop. This requires the use of universal quantifiers over state variables, to isolate the different conditions.</p><p>In this paper we use a different approach that produces a set of independent verification conditions, dispensing with the introduction of quantifiers. This approach requires calculating a notion of precondition that is related to wlp, but differs in that the precondition of a loop is simply defined as being simply its invariant, regardless of whether termination is guaranteed or not. The figure shows the definition of the function wprec corresponding to this notion. Throughout the paper whenever we refer to a weak precondition of a program, we mean a condition calculated by this function. The figure also contains the definition of the function spost, corresponding to the symmetric notion of a strong postcondition that will be true of the final state of the program S when its execution starts in a state satisfying P . The syntax of assertions (used as preconditions, postconditions, and loop invariants), also given in the figure, is obtained as an extension of boolean expressions with implication and first-order quantification.</p><p>Verification conditions for partial correctness An alternative way to calculate verification conditions is based on Hoare logic <ref type="bibr" target="#b15">[Hoa69]</ref>. In this approach the verification conditions required for the partial correctness of the program S with respect to specification (P , Q) are the side conditions of a derivation (or proof tree) of the logic. If the verification conditions are all valid, then it is possible to construct a derivation with the Hoare triple {P } S {Q} as conclusion, in which case S is (partially) correct.</p><p>The derivations with a given conclusion are not unique; although they do not need to be explicitly constructed in order for the side conditions to be obtained, some strategy is still necessary to direct the process. In this paper we will use two such strategies, based on weak preconditions and on strong postconditions respectively. Technically, these strategies are responsible for selecting intermediate conditions for the sequence rule of Hoare logic: when considering a derivation for the triple {P } S 1 ; S 2 {Q}, this rule states that two derivations should be recursively considered, for the triples {P } S 1 {R} and {R} S 2 {Q} for some condition R. Our first strategy sets R to be wprec(S 2 , Q); the second strategy sets R to be spost(S 1 , P ).</p><p>Each of these strategies results in a different set of verification conditions, defined as follows.</p><formula xml:id="formula_0">VCG w (P , S , Q) {P → wprec(S , Q)} ∪ VC w (S , Q) and VCG s (P , S , Q) VC s (S , P ) ∪ {spost(S , P ) → Q}</formula><p>where the functions VC w and VC s are also defined in the figure. These auxiliary functions are responsible for traversing the implicit derivations and collecting the side conditions along the way. The traversals are based uniquely on one of the conditions given in the specification (the postcondition and precondition respectively); the additional formula P → wprec(S , Q) (resp. spost(S , P ) → Q) added to this set is the principal verification condition of the program, stating that the specification's precondition is stronger than the calculated precondition (resp. the specification's postcondition is weaker than the calculated postcondition). For programs not containing loops, this is the single verification condition.</p><p>The generation of verification conditions should of course be sound with respect to the operational semantics of the language: if they are all valid then this should constitute a guarantee that the program is indeed correct with respect to its specification (P , Q):</p><p>If either | VCG w (P , S , Q) or | VCG s (P , S , Q) and S is run in a state that satisfies P , then if S terminates the final state satisfies Q. This is easy to prove for such a simple language, with respect to a standard evaluation semantics. The reader is directed to <ref type="bibr" target="#b13">[FP11]</ref> for a proof, and also for more details on verification conditions and their relation to Hoare logic and Dijkstra's predicate transformers.</p><p>We can state a correspondence result between both strategies as follows. Let | A, with A a set of first-order formulas, denote the fact that | A i for every A i ∈ A (set union will be denoted by commas).</p><p>Lemma 1 For every precondition P , postcondition Q, and program S ,</p><formula xml:id="formula_1">| VCG w (P , S , Q) iff | VCG s (P , S , Q)</formula><p>Proof By induction on the structure of S . For the case where S is while b do {I } S b the following is used as induction hypothesis:</p><formula xml:id="formula_2">| VCG w (I ∧ b, S b , I ) iff | VCG s (I ∧ b, S b , I ).</formula><p>Since our language has integer variables only, verifying the correctness of programs can be achieved by applying the VCGen and exporting the resulting proof obligations to a proof tool capable of reasoning with integer arithmetics. The result is a framework for the verification of programs with annotated loop invariants.</p><p>Observe that this is not a fully automated method since it requires users to provide the annotations. Furthermore, undecidability of first-order logic means that interactive proof is often necessary, but it must also be noted that the power of automatic proof has progressed significantly in recent years. Real-language implementations of many standard algorithms can now be proved fully automatically, which is certainly a great advance with respect to what could be achieved, say, 10 years ago. Recent approaches build in particular on advances in SMT solvers (that combine useful programming theories), and also on combinations of automatic provers (for the easy proofs) and interactive proof assistants (for the hard parts).</p><p>In the scope of program verification, failure of automatic proof does not mean a program is not correct, it just means that interactive proof should be used instead to clarify whether a given proof obligation is indeed invalid or not. In the scope of the slicing techniques considered in this paper, proof obligations are generated to authorize the removal of a given set of statements. Slicing should be conservative, so failure of an attempt to discharge a particular obligation implies that the set of statements being considered should not be removed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Verification conditions for total correctness</head><p>In a total correctness setting the verification conditions are further required to guarantee termination of programs. In our language no procedures or functions are present and expression evaluation always terminates, so what is required is that every loop in a given program terminates. For this we require each loop to contain an additional annotation, an integer expression e v called a loop variant:</p><formula xml:id="formula_3">Comm C :: . . . | while b do {A, e v } S</formula><p>If for every loop in the program the value of the respective variant is initially non-negative and strictly decreases with each iteration while remaining nonnegative until the last iteration, the program is guaranteed to terminate. The VCGens of Fig. <ref type="figure" target="#fig_0">1</ref> can be extended to cope with total correctness by simply modifying the verification conditions of loops. The function VC w t (resp. VC s t ) has the same definition as VC w (resp. VC s ) except for the case of loops, which is given as follows for a loop annotated with invariant I and variant e v :</p><formula xml:id="formula_4">VC w t (while b do {I , e v } S , Q) {I ∧ b → e v ≥ 0, I ∧ b ∧ e v x 0 → wprec(S , I ∧ e v &lt; x 0 ), I ∧ ¬b → Q} ∪ VC w t (S , I ∧ e v &lt; x 0 ) VC s t (while b do {I , e v } S , P ) {I ∧ b → e v ≥ 0, P → I , spost(S , I ∧ b ∧ e v x 0 ) → I ∧ e v &lt; x 0 } ∪ VC s t (S , I ∧ b ∧ e v x 0 )</formula><p>Note that the weak precondition and strong postcondition functions wprec and spost are still defined as before. Note also the use of an auxiliary variable x 0 to store the initial value of the variant (regarding an arbitrary loop iteration), which then allows us to force the postcondition e v &lt; x 0 .<ref type="foot" target="#foot_2">2</ref> Now we let which is in accordance with the fact that total correctness is a stronger notion than partial correctness. In fact, in practice the total correctness of a program is often established by first proving its partial correctness and then additionally checking that it terminates on initial states satisfying the precondition.</p><formula xml:id="formula_5">VCG w t (P , S , Q) {P → wprec(S , Q)} ∪ VC w t (S ,</formula><p>Finally, the following lemma states that the weak precondition and the strong postcondition strategies are equivalent for calculating total correctness verification conditions: Lemma 2 For every precondition P , postcondition Q, and program S ,</p><formula xml:id="formula_6">| VCG w t (P , S , Q) iff | VCG s t (P , S , Q)</formula><p>Proof By induction on the structure of S . For the case where S is while b do {I , e v } S b , the following is used as induction hypothesis:</p><formula xml:id="formula_7">| VCG w t (I ∧ b ∧ e v x 0 , S b , I ∧ e v &lt; x 0 ) iff | VCG s t (I ∧ b ∧ e v x 0 , S b , I ∧ e v &lt; x 0 ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 2. Definition of relation "is portion of"</head><p>Notation and auxiliary definitions Let S C 1 ; . . . ; C n , 1 ≤ k ≤ n. We will use dedicated notation for the weak precondition of a suffix of S and the strong postcondition of a prefix of S , as well as for the (partial correctness) verification conditions of both, as follows.</p><formula xml:id="formula_8">wprec k (S , Q) wprec(C k ; C k +1 ; . . . ; C n , Q) VC w [k ](S , Q) VC w (C k ; C k +1 ; . . . ; C n , Q) wprec n+1 (S , Q) Q VC w [n + 1](S , Q) {} spost 0 (S , P ) P VC s [0](S , P ) {} spost k (S , P ) spost(C 1 ; . . . ; C k −1 ; C k , P ) VC s [k ](S , P ) VC s (C 1 ; . . . ; C k −1 ; C k , P )</formula><p>VC w t and VC s t will also be used with the obvious meaning. We will additionally employ the following notation for the sequence obtained by removing a subsequence of S . For 1</p><formula xml:id="formula_9">≤ i ≤ j ≤ n, remove(i , j , S ) skip if i 1 and j n, C 1 ; . . . ; C i−1 ; C j +1 ; . . . ; C n otherwise.</formula><p>Finally, we will write S S with the meaning that program S results from S by removing some statements. S is said to be a portion or a reduction of S . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Assertion-based slicing: a review</head><p>In this section we discuss the existent notions of slicing based on preconditions and postconditions, as well as algorithms for calculating them. Other related approaches are discussed in Sect. 3.5, in particular the notions of forward and backward conditioned slice.</p><p>We use the expression assertion-based slicing to encompass postcondition-based, precondition-based, and specification-based forms of slicing, which will be considered in turn in what follows. It is important to keep in mind the distinction between the definition of some form of slicing (which states when a program is a slice of another based on a given criterion), and algorithms for computing such slices. The fact that definitions and algorithms have often been introduced simultaneously in the same papers may cause some confusion between the two. Typically a definition admits more than one slice based on the same criterion, and an algorithm computes one particular slice in accordance with the definition.</p><p>This section is intended to introduce the reader to the key concepts of slicing based on assertions, but also to identify some limitations in the published work, which we then go on to solve in the rest of the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.">Postcondition-based slicing</head><p>The idea of slicing programs based on their specifications was introduced by Comuzzi et al. <ref type="bibr" target="#b7">[CH96]</ref> with the notion of predicate slice (p-slice), also known as postcondition-based slice. To understand the idea of p-slices, consider a program S and a given postcondition Q. It may well be the case that some of the commands in the program do not contribute to the truth of Q in the final state of the program, i.e. their presence is not required in order for the postcondition to hold. In this case, the commands may be removed. A crucial point here is that the considered set of executions of the program is restricted to those that will result in the postcondition being satisfied upon termination. In other words, not every initial state is admissible-only those for which the weak precondition of the program with respect to Q holds.</p><p>Consider for instance Program 1. The postcondition Q x ≥ 0 yields the weak precondition x ≥ −50. If the program is executed in a state in which this precondition holds and the commands in lines 2 and 3 are removed from it, the postcondition Q will still hold. To convince ourselves of this, it suffices to notice that after execution of the instruction in line 1 in a state in which the weak precondition is true, the condition x ≥ 50 will hold, which is in fact stronger than Q.</p><p>To be more systematic, for a program of the form C 1 ; . . . ; C n with postcondition Q, if | wprec i (S , Q) → wprec j (S , Q), with i &lt; j , the sequence C i ; . . . ; C j −1 can be removed. In particular, if | wprec i (S , Q) → Q, the sequence C i ; . . . ; C n can be removed. For the previous example we have</p><formula xml:id="formula_10">wprec 3 (S , Q) x ≥ 100, wprec 2 (S , Q) x ≥ 50, wprec 1 (S , Q) x ≥ −50.</formula><p>Now observe that | wprec 2 (S , Q) → Q, which means that the instructions in lines 2 to 3 can in fact be removed: the postcondition Q will still hold for the sliced program when it is executed in a state satisfying x ≥ −50. §</p><p>x := x−150;</p><p>x := x +100;</p><p>x := x+100 ¦ ¥ Program 2: Example for postcondition-based slicing P-slices are of course not unique. For instance since | wprec 3 (S , Q) → Q as well, we could have chosen to remove only the instruction in line 3. Informally we can say that given a set of slices of a program with respect to the same postcondition, the best slice is the one in which the largest number of instructions is removed. It is also important to understand that not only suffixes of a sequence of commands may be removed. Consider the postcondition Q x ≥ 0 for Program 2, which yields the following weak preconditions</p><formula xml:id="formula_11">wprec 3 (S , Q) x ≥ −100, wprec 2 (S , Q) x ≥ −200, wprec 1 (S , Q) x ≥ −50</formula><p>Note that although | wprec 1 (S , Q) → Q, the commands in lines 1 and 2 can be removed because | wprec 1 (S , Q) → wprec 3 (S , Q). If the statement in line 3 is executed in a state in which x ≥ −50 then the postcondition x ≥ 0 will hold. We remark that in the limit, the set of executions that lead to the postcondition being satisfied may be empty (if the weak precondition of the program is a contradiction, say x &lt; 0 ∧ x &gt; 10), in which case there exist no slices-the formal definition to be given below will clarify this point. Another extreme situation occurs when the postcondition is a valid assertion, say x &lt; 0 ∨ x &gt; −10, in which case the entire program is seen as irrelevant, and admits as a slice the trivial program skip.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Calculating p-slices</head><p>It is easy to see how p-slices of a sequence of commands S C 1 ; . . . ; C n can be computed with respect to a postcondition Q. The first step is of course to calculate the weak preconditions wprec i (S , Q), for 1 ≤ i ≤ n, and to store this information, say in the abstract syntax tree of S . The next step is to iterate the following basic procedure that attempts to remove the subsequence C i ; . . . ; C j −1 , with 1 ≤ i &lt; j ≤ n:</p><formula xml:id="formula_12">• If | wprec i (S , Q) → wprec j (S , Q) then slice S to remove(i , j − 1, S )</formula><p>This involves a trade-off between the number of proof obligations generated (each of which results in a call to the prover) and the potential number of lines that will be removed from the program. Suppose for instance that we limit ourselves to removing suffixes of the initial program. The smallest such slice can be calculated with a linear number of calls to the prover (on the length of S ), by fixing j n + 1 (thus wprec j (S , Q) Q). It suffices, in the second step above, to initialize i 1, and then execute the following loop: the prover is invoked with the formula wprec i (S , Q) → Q; if unsuccessful then i is incremented and a new iteration of the loop takes place; otherwise the algorithm stops. The resulting slice is C 1 ; . . .</p><formula xml:id="formula_13">; C i−1 .</formula><p>Notice that this is of course a conservative approach: failure of the prover to establish the validity of the first-order formula wprec i (S , Q) → Q does not mean that the formula is not valid, but this uncertainty implies that removing the sequence C i ; . . . ;C n might result in a program that is not a slice of S , so the algorithm proceeds to the next candidate suffix.</p><p>It is easy to understand that the same program may contain several removable subsequences, including prefixes, suffixes, and sequences that are neither prefixes nor suffixes. Moreover, these removable sequences may well overlap. Thus it is clear that no linear-time algorithm can possibly detect all removable sequences, let alone select the smallest slice. §</p><p>x := x +100;</p><p>x := x−200;</p><p>x := x+200 ¦ ¥ Program 3: Example for precondition-based slicing</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The original quadratic time algorithm</head><p>The algorithm proposed by Comuzzi runs in quadratic time on the length of the sequence. <ref type="foot" target="#foot_3">3</ref> The algorithm first tries to slice the entire program by removing its longest removable suffix, and then repeats this task, considering successively shorter prefixes of the resulting program, and removing their longest removable suffixes. Schematically:</p><formula xml:id="formula_14">for j n + 1, n, . . . , 2 for i 1, . . . , j − 1 if valid wprec i (S , Q) → wprec j (S , Q) then S ← remove(i , j − 1, S )</formula><p>For instance in a program with 999 statements the following pairs (i , j ) would be considered in this order:</p><p>(1, 1000), (2, 1000), . . . , (999, 1000), (1, 999), (2, 999), . . . , (998, 999), (1, 998), . . . This algorithm may fail to remove the longest sequence. Consider that | wprec 1 (S , Q) → wprec 800 (S , Q) and | wprec 700 (S , Q) → wprec 900 (S , Q). Two subsequences may be sliced off, consisting respectively of commands 1 to 799 and 700 to 899. The algorithm will consider (and remove) the shorter sequence first, and in doing so will eliminate the possibility of the longer sequence being considered, since line 800 will be removed (and it may happen that wprec 1 (S , Q) is not stronger than any remaining wprec k (S , Q)). The resulting slice is thus not minimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>An improved quadratic algorithm</head><p>An alternative to Comuzzi's algorithm can be described as follows. We start with the entire program and consider in turn successively shorter sequences as candidates to be removed. Thus in the 999 statements program one would consider sequences in the order (1, 1000), (1, 999), (2, 1000), (1, 998), (2, 999), (3, 1000), (1, 997), . . . This would certainly remove the longest removable sequence.</p><p>This algorithm is however not optimal either. Consider the case in which | wprec 1 (S , Q) → wprec 400 (S , Q), | wprec 600 (S , Q) → wprec 1000 (S , Q), and | wprec 200 (S , Q) → wprec 800 (S , Q). The longest sequence will be sliced off (600 program lines), but this will preclude the possibility of eliminating two shorter sequences that would together consist of 800 program lines: removing the larger contiguous sequence does not necessarily result in the smallest slice. In fact it should now be clear that considering all sequences in any given order cannot guarantee that the minimal slice is computed. The same is true for precondition-based and specification-based slices, discussed below. In Sect. 7 we will show that this problem can in general be formulated as a graph problem, which is one of the contributions of the present paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.">Precondition-based slicing</head><p>Chung and colleagues <ref type="bibr" target="#b8">[CLYK01]</ref> later introduced precondition-based slicing as the dual notion of postconditionbased slicing. The idea is still to remove statements whose presence does not affect properties of the final state of a program. The difference is that the considered set of executions of the program is now restricted directly through a first-order condition on the initial state. Statements whose absence does not violate any property of the final state of any such execution can be removed. This is the same as saying that the assertion calculated as the strong postcondition of the program (resulting from propagating forward the given precondition) is not weakened in the computed slice. § x ≥ 0. The effect of the first two instructions is to weaken the precondition. If these instructions are sliced off and the resulting program is executed in a state in which P holds, whatever postcondition held for the initial program will still hold for the sliced program.</p><p>To be systematic, for a program of the form C 1 ; . . . ; C n with precondition P , if | spost i (S , P ) → spost j (S , P ), with i &lt; j , the sequence C i+1 ; . . . ; C j can be removed. In particular, if | P → spost j (S , P ), the sequence C 1 ; . . . ; C j can be removed. For the previous example we have</p><formula xml:id="formula_15">spost 1 (S , P ) ∃v .v ≥ 0 ∧ x v + 100 ≡ x ≥ 100, spost 2 (S , P ) ∃v .v ≥ 100 ∧ x v − 200 ≡ x ≥ −100, spost 3 (S , P ) ∃v .v ≥ −100 ∧ x v + 200 ≡ x ≥ 100</formula><p>We see that | P → spost 2 (S , P ), thus the first two commands can be sliced off. Similarly to postcondition-based slicing, we are not limited to removing prefixes (even though only prefixes are considered by the linear time algorithm proposed in <ref type="bibr" target="#b8">[CLYK01]</ref>). In the same example program, since in fact | spost 1 (S , P ) → spost 3 (S , P ), we could alternatively slice off lines 2 and 3 of the program, which shows that removable sequences may overlap. As a final example, consider a program containing branching, Program 4 (top). Again slicing the programinvolves computing its strong postcondition with respect to a given precondition P . Both branches consist of sequences of commands; even if the conditional command itself cannot be sliced off, it may well be the case that the branch subprograms can be sliced. To this effect, we strengthen the precondition with the boolean condition and its negation respectively, and slice each branch with respect to these strengthened preconditions. Let S 1 be x : x + 100; x : x − 200; x : x + 200 and S 2 be x : x − 150; x : x − 100; x : x + 100. S 1 will be sliced with respect to P 1 P ∧ x ≥ 0 and S 2 with respect to P 2 P ∧ x ≥ 0. Now let P be x ≥ 0. Then P 1 ≡ x ≥ 0 and P 2 is a contradiction, which means that | P 2 → spost(S 2 , P 2 ). Consequently, S 2 will be sliced to skip. This makes sense, since the precondition eliminates the possibility of execution of the else branch of the conditional. On the other hand the then branch is just the previous example (Program 3). Thus Program 4 can be precondition-sliced with respect to x ≥ 0 as shown at the bottom.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.">Specification-based slicing</head><p>A specification-based slice can be calculated when both a precondition P and a postcondition Q are given for a program S . The set of relevant executions is restricted to those for which Q holds upon termination when the program is executed in a state satisfying P . Programs resulting from S by removing a set of statements, and which are still correct regarding (P , Q), are said to be specification-based slices of S with respect to (P , Q). § The method proposed in <ref type="bibr" target="#b8">[CLYK01]</ref> to compute such slices is based on a theorem proved by the authors, which states that the composition, in any order, of postcondition-based slicing (with respect to postcondition Q) and precondition-based slicing (with respect to precondition P ) produces a specification-based slice with respect to (P , Q). As an example consider Program 5 and the specification (y &gt; 10, x ≥ 0). Precondition-based slicing will slice both sequences inside the conditional by strengthening the precondition y &gt; 10 with the condition y &gt; 0 and its negation respectively. In the second case this yields a contradiction, which will result in the else branch sequence being completely sliced off. The then sequence branch is not affected. Postcondition-based slicing with respect to x ≥ 0 will then produce the sliced program shown at the bottom of the listing. <ref type="foot" target="#foot_4">4</ref>Although this method does compute specification-based slices, it does not compute minimal slices, as can be seen by looking at Program 6 with specification (true, x ≥ 100). We have:</p><formula xml:id="formula_16">spost 0 (S , P ) true spost 1 (S , P ) ∃v .x v * v spost 2 (S , P ) ∃w .(∃v .w v * v ) ∧ x w + 100 ≡ ∃v .x v * v + 100 spost 3 (S , P ) ∃w .(∃v .w v * v + 100) ∧ x w + 50 ≡ ∃v .x v * v + 150</formula><p>and</p><formula xml:id="formula_17">wprec 4 (S , Q) x ≥ 100 Q wprec 3 (S , Q) x ≥ 50 wprec 2 (S , Q) x ≥ −50 wprec 1 (S , Q) true</formula><p>It is obvious that the postcondition is satisfied after execution of the instruction in line 2, which means that if line 3 is removed the sliced program will still be correct with respect to (true, x ≥ 100). However, precondition-based and postcondition-based slicing both fail in removing this instruction, since no forward implications are valid among the spost i (S , P ) or the wprec i (S , Q). Composing precondition-based and postcondition-based slicing will of course not solve this fundamental flaw. In Sect. 5 we show that the precise identification of removable statements requires the simultaneous use of both preconditions and postconditions; trying to identify removable statements using only preconditions or only postconditions may fail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.">Formalization</head><p>We now formalize the notions of slicing reviewed in this section. A program S is a specification-based slice of S if it is a portion of S and moreover S can be refined to S with respect to a given specification (a semantic notion). The notions of precondition-based and postcondition-based slice can be defined as special cases of this notion. </p><formula xml:id="formula_18">Q if S (wprec(S ,Q),Q) S .</formula><p>Observe that it only makes sense to calculate specification-based slices of correct programs; if S is not correct with respect to (P , Q) then any portion of it is a slice with respect to (P , Q). This does not however mean that techniques based on these forms of slicing cannot be applied to incorrect programs: they can be used on subprograms (proved correct) of incorrect programs. For instance in Sect. 4 we will see how postcondition-based slicing can be used for debugging purposes. Note also that the definitions of precondition-based and postcondition-based slicing are very strong, as the following lemma shows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 3</head><p>1. If S is a precondition-based slice of S with respect to P , then for any assertion Q, S (P ,Q) S 2. If S is a postcondition-based slice of S with respect to Q, then for any assertion P , S (P ,Q) S Proof We prove 1 (the proof of 2 is similar). We assume | VCG w (P , S , Q), and thus by Lemma 1 | spost(S , P ) → Q, VC s (S , P ), and have to prove that | VCG w (P , S , Q). Since S is a precondition-based slice of S with respect to P , by Lemma 1 we have that | spost(S , P ) → spost(S , P ), VC s (S , P ) implies | spost(S , P ) → spost(S , P ), VC s (S , P )</p><p>The left-hand side follows from our assumptions, and thus | spost(S , P ) → Q, VC s (S , P ) which by the same lemma is equivalent to | VCG w (P , S , Q).</p><p>We must remark at this point that there are several differences between our definitions and those used in <ref type="bibr" target="#b7">[CH96,</ref><ref type="bibr" target="#b8">CLYK01]</ref>. A first difference concerns all the above notions of slicing: previous notions require the weak precondition (resp. strong postcondition) to be exactly the same in the sliced program as in the original program, whereas we allow for it to be weaker (resp. stronger), which is more coherent with the idea of the slice refining the behaviour of the original program.</p><p>A second difference concerns specifically the definitions of precondition-based and postcondition-based slicing only. While the definitions given in <ref type="bibr" target="#b8">[CLYK01]</ref> are based on implicative assertions relating the strong postconditions (resp. weak preconditions) of both programs, we explicitly define them as particular cases of specification-based slices, which is more convenient given our treatment of iteration through the use of annotated invariants. The following lemma makes the relation between both definitions explicit, for the case of programs without iteration. The above definitions are formulated in a partial correctness setting, which means that terminating programs admit non-terminating programs as specification-based slices, and vice versa (it is easy to see that removing a single instruction from the body of a terminating loop may make it non-terminating, and vice versa). We will now introduce termination-sensitive notions of slicing, by shifting from a partial correctness to a total correctness setting. A terminating program does not admit non-terminating programs as termination-sensitive slices. </p><formula xml:id="formula_19">Q if S (wprec(S ,Q),Q) S .</formula><p>In the same way that, when verifying a program, one may proceed by first checking its partial correctness and then its termination to ensure total correctness, one may assert that S is a termination-sensitive slice of the totally correct program S by checking that S (P ,Q) S and additionally checking that S terminates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.">Related approaches</head><p>In this section we review other forms of slicing that have some points in common with assertion-based slicing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Semantic slicing</head><p>One of the most successful lines of work in the area of slicing has been conducted by Ward and colleagues. This line has focused on semantic forms of slicing, in the sense that slices are obtained by combining syntactic operations with classic semantics-preserving program transformations such as loop unrolling and constant propagation. The results are both practical (a commercially-available workbench has been developed) and theoretical. In particular, the recent paper <ref type="bibr" target="#b17">[War09]</ref> provides a clarifying analysis of slicing properties and definitions proposed by different authors (both syntactic and semantic). Our work in this paper clearly stands on the semantic side, but a fundamental difference with respect to other work on semantic slicing is that we focus on code annotated with assertions. Our slicing criteria are exclusively provided by such assertions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conditioned slicing</head><p>Shortly after the definition of postcondition-based slicing by Comuzzi and Hart, Canfora et al. <ref type="bibr" target="#b6">[CCL98]</ref> introduced the notion of conditioned slicing, together with a tool to calculate such slices. Similarly to precondition-based slicing, conditioned slicing uses preconditions as a means to specify a set of initial states for computing a forward slice. The main points to understand about conditioned slicing are 1. The precondition is used in combination with traditional slicing techniques based on dependency analysis.</p><p>Code will be removed either because it is unreachable (not executed when the program is started in a state in which the precondition holds), or because it is dead (the precondition eliminates dependencies involving it). Consider the following example from Canfora's paper:</p><formula xml:id="formula_20">§ 1 x := y+2; 2 i f ( a &gt; 0) 3 x := y * 2 ; 4 z := x+1 ¦ ¥</formula><p>A conditioned slice of this program based on any precondition P such that | P → a &gt; 0 results in line 1 being eliminated, since line 3 will certainly be executed and cancel the effect of line 1. This example shows a fundamental difference between conditioned slicing and earlier notions of slicing exclusively based on control and data dependencies. Clearly static dependencies alone cannot be used to implement conditioned slicing, since the instruction in line 4 depends on all previous instructions. The algorithm proposed by the authors is based on symbolic execution, which allows for the relevant dependency paths to be identified. A theorem prover is called externally to guide the symbolic execution. 2. In the context of traditional, dependency-based slicing, there are two standard types of forward slicing: static, which considers every possible execution (i.e. all initial states), and dynamic, which is concerned with a single execution (a concrete initial state) of the program. The latter can be generalized to cope with a set of concrete executions, but an interesting aspect of conditioned slicing is that it subsumes all these notions, since a characterization of the set of initial states by a first-order condition can be used to admit any initial state (if the condition is true), or just a concrete initial state (if the condition is a conjunction of equality formulas, each equating a program variable to a constant), or any other intermediate set of initial states. 3. The similarities between precondition-based slicing and conditioned slicing should be clear: even though the latter is based on dependencies and the former on weak preconditions and strong postconditions, both are capable of eliminating conditionally unreachable and conditionally dead code. These are examples of code that is redundant with respect to a given precondition, but note that the notion of redundancy is different in both cases: whereas in precondition-based slicing this is code that, if removed, results in a program whose strong postcondition will not be weakened with respect to the initial program, in conditioned slicing this is code that does not contribute to the values of a given set of variables. Precondition-based slicing removes other forms of redundancy that conditioned slicing cannot remove, since they can only be detected at a semantic level. Program 4 is a good example to illustrate this point: while conditioned slicing with x ≥ 0 would eliminate the else branch, it would not remove the two assignment commands inside the then branch, which are removed by precondition-based slicing. 4. Conditioned slicing criteria are not however limited to a precondition P : a slicing criterion consists additionally of a subset X of the program variables, as well as a specific program line k . The program statements eliminated are those that do not affect the value of any variable in X at line k , for executions starting in states satisfying P . Precondition-based slicing does not subsume conditioned slicing, since it does not take into account these criteria, inherited from standard dependency-based forms of slicing (see also Sect. 8 below). 5. For conditioned slicing criteria that focus on the final state of the program (i.e. k is the last line), preconditionbased slicing can be said to be a stronger form of slicing than conditioned slicing, since it eliminates code using semantic criteria that cannot be expressed in terms of dependencies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Backward conditioned slicing</head><p>Backward conditioning was introduced by Fox and colleagues <ref type="bibr" target="#b12">[FDHH01]</ref> as the symmetric notion of conditioned slicing. A slicing criterion includes a postcond Q that is used in the following way: statements whose presence forces ¬Q to hold in the final state (i.e. if they are present ¬Q will hold after every execution) are removed.</p><p>The technique is intended as the dual of conditioned slicing: whereas (forward) conditioned slicing eliminates the code that will surely not be executed when the given precondition holds, backward conditioned slicing eliminates the code that cannot be executed if the given postcondition is to be satisfied in the final state, i.e. it eliminates statements that prevent the given postcondition from being true. The technique is introduced with program comprehension as main application. The authors also propose an algorithm for implementing backward conditioned slicing, based on symbolic execution and an external theorem prover.</p><p>A second paper [HHF + 01] combines forward and backward conditioned slicing, based on a precondition P and a postcondition Q: it eliminates code that leads to Q being false when the program is executed in states satisfying P . The motivation of the latter work is the application to program verification. The idea here is that to check if a program is correct w.r.t. a specification (P , Q), one may compute its conditioned slice w.r.t. (P , ¬Q). If the program is correct this slice will be empty, since all execution paths lead to Q being true, and all instructions will thus be removed. If the program is not correct, the instructions that remain in the slice are those that may for some initial states lead to ¬Q being true. Such instructions should carefully be considered since they are directly contributing to the program being incorrect. This forward/backward form of conditioned slicing cannot be formulated as specification-based slicing with respect to a specification. While a specification-based slice S of program S with respect to (P , Q) is correct with respect to (P , Q), a conditioned slice S with respect to (P , Q) is characterized by not being correct with respect to (P , ¬Q). Another way to put this is that while we require VCG w (P , S , Q) to be valid, VCG w (P , S , Q) must instead be satisfiable. For instance the command x : x + 10 with precondition x &gt; 10 and postcondition x ≤ 20 should be sliced to skip, since | VCG w (x &gt; 10, x : x + 10, ¬(x ≤ 20)) and | VCG w (x &gt; 10, skip, ¬(x ≤ 20)), i.e. the formulas VCG w (x &gt; 10, skip, x ≤ 20) are satisfiable.</p><p>We speculate that the graph-based algorithms studied in this paper could be adapted to the purpose of computing forward/backward conditioned slices by using satisfiability checks instead of validity checks.</p><p>In the next section, before focusing on the core contributions of the paper, we will briefly consider some applications of slicing based on assertions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Applications of assertion-based slices</head><p>Postcondition-based and precondition-based slicing can both be seen as program specialization techniques regarding a restricted set of executions of a program. A postcondition-based slice of a program S may have a weaker weak precondition than S , and a precondition-based slice of S may have a stronger strong postcondition than S . We start by considering applications of these forms of slicing and then turn to specification-based slicing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Postcondition-based slicing</head><p>In their paper Comuzzi and Hart give a number of examples of the usefulness of postcondition-based slicing, based on their experience as software developers and maintainers. Their emphasis is on applying slicing to relatively small fragments of big programs, using postconditions corresponding to properties that should be preserved by these fragments. Suppose one suspects that a problem was caused by some property Q being false at line k of a program S with n lines of code. We can take the subprogram S k consisting of the first k lines of S and slice it with respect to the postcondition Q. This may result in a suffix of S k being sliced off, say from lines i to k , which means that in order for Q to hold at line k , it must also hold at line i . The resulting slice is where the software engineers should now concentrate in order to find the problem (a similar reasoning applies if the sequence of lines removed is not a suffix of S k ).</p><p>A related situation occurs when the property must deliberately be violated in some part of the code. This is typical for instance of code running as a thread of a concurrent program, with Q being true outside a critical section executed by the thread at some point, and false inside that section. Q is true before entering the said critical section and will be true after leaving it, so postcondition-based slicing can be used to study the correct behaviour of the code with respect to that section. Similarly, the property may correspond to some invariant of a data structure, say a balanced binary search tree that will temporarily be unbalanced (or even inconsistent) while a new element is being inserted.</p><p>Safety properties may also be studied in this way. Examples include for instance</p><p>• array accesses u[e], with safety property "the value of expression e stands between 0 and N − 1", with N the allocated size of the array; • pointer dereferencing accesses * p with safety property "p points to a properly allocated memory region"; • procedure invocations, with safety property "the precondition of the invoked procedure is satisfied".</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Precondition-based slicing</head><p>Redundant code is code that does not produce any effect: removing it results in a program that behaves in the same way as the original. Note that we say "the code does not produce any effect" in the sense of observable effects on the final state. Removing redundant code may of course result in code that is different regarding the execution traces; in particular the resulting code may be faster to execute. A major application of precondition-based slicing is the removal of conditionally redundant code, i.e. code that is redundant for executions of the program specified by a given precondition. Naturally, redundant code is a special case of conditionally redundant code. § 1 x := y + 2; Examples of redundancies include sequences of instructions like x : x − 200 ; x : x + 200, as in Program 3. Previously in Sect. 3 we saw how precondition-based slicing with respect to the precondition x ≥ 0 indeed removed these two instructions. It is however clear that the instructions should be removable also for executions not allowed by this precondition. Let us now consider how this can be done.</p><p>A first attempt could be to slice the program with respect to the precondition true. For Program 3 we would have</p><formula xml:id="formula_21">spost 1 (S , true) ∃v .x v + 100 ≡ true, spost 2 (S , true) ∃v .x v − 200 ≡ true, spost 3 (S , true) ∃v .x v + 200</formula><p>≡ true the entire program can now be sliced off, since its calculated postcondition is a valid assertion-not what we had in mind. What is missing here is a way to record the initial state, to be able to compare the values of variables in different states using the initial values as a reference. For this purpose we resort to auxiliary variables, that are used in assertions only, not in the code. The use of these variables makes postcondition calculations resemble a symbolic execution of the code, in which the values of the variables after the execution of each command are related to the initial values through equality formulas.</p><p>Let us slice the same program with respect to the precondition x x 0 , where the auxiliary variable x 0 is used to record the initial value of x : spost 1 (S , x x 0 ) ∃v .v x 0 ∧ x v + 100 ≡ x x 0 + 100, spost 2 (S , x x 0 ) ∃v .v x 0 + 100 ∧ x v − 200 ≡ x x 0 − 100, spost 3 (S , x x 0 ) ∃v .v x 0 − 100 ∧ x v + 200 ≡ x x 0 + 100 Notice that the precondition does not restrict the set of executions, since x 0 is not a program variable. Since | spost 1 (S , true) → spost 3 (S , true), the statements in lines 2 and 3 of the program can be sliced off, because they are redundant and unnecessary in any execution of the program. Two particular forms of redundant code are unreachable code, which is not executed, and dead code, which is executed but produces no effect, because the final values of variables do not depend on its results. An example of unreachable code is the block S 2 in if 10 &gt; 5 then S 1 else S 2 ; an example of dead code is the first instruction in Program 7. Unreachable code and dead code elimination are typically part of the optimizations performed by compilers, using control flow and data flow analyses. Specification-base slicing allows for conditional versions of these notions, eliminating code that is unreachable or dead for a given set of executions. Conditional unreachable code elimination was already exemplified with Program 4 in Sect. 3.2-unreachable code is eliminated because (for the given initial states) its presence does not influence the final state of the program. Precondition-based slicing can thus be used to study the control flow of a program.</p><p>Let us now consider an example of (unconditional) dead code elimination. So far we have been identifying slices by checking the validity of implicative formulas involving propagated strong postconditions. As hinted in the previous section, this technique cannot eliminate all types of redundant code, which this example will also illustrate. Let S be Program 7. Clearly, in every execution of this program, the first statement is dead since its effect is cancelled by the second statement. To slice this program using the precondition x x 0 ∧ y y 0 we compute the strong postconditions as follows: spost 0 (S , x x 0 ∧ y y 0 ) x x 0 ∧ y y 0 spost 1 (S , x x 0 ∧ y y 0 ) ∃v .v x 0 ∧ y y 0 ∧ x y + 2 ≡ x y 0 + 2 ∧ y y 0 , spost 2 (S , x x 0 ∧ y y 0 ) ∃v .v y 0 + 2 ∧ y y 0 ∧ x y * 2 ≡ x y 0 * 2 ∧ y y 0 § x := y+2; i f ( a &gt; 0)</p><p>t h e n x := y * 2 ; x 0 ∧ y y 0 ) → spost 1 (S , x x 0 ∧ y y 0 ), the first statement cannot be sliced off. Clearly, it would be impossible to reach the conclusion that this statement is dead by relating the calculated strong postconditions only, since spost 0 (S , x x 0 ∧ y y 0 ) and spost 1 (S , x x 0 ∧ y y 0 ) are calculated without even looking at subsequent commands. Below we will see that using a specification-based slicing technique to compute precondition-based slices will allow for commands like these to be removed as expected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Specification-based slicing</head><p>A first application of this form of slicing concerns the removal of redundant code. We saw above that the traditional precondition-based slicing algorithm is unable to remove all such code, specifically when a "look ahead" would be required to reach the conclusion that a given statement can be removed. Specification-based slicing combines strong postcondition with weak precondition computations, and can be used to properly eliminate redundant code. Let S be a program with variables x 1 , . . . , x n . In order to remove unnecessary code taking into account every execution of S , it suffices to slice S with respect to the following specification (the x i 0 are auxiliary variables).</p><p>(x 1 x 1 0 , . . . , x n x n 0 , spost(S , x 1 x 1 0 , . . . , x n x n 0 )) Note that, following Definition 2 (2), the result will still be a precondition-based slice-the problem of our previous attempt was not in the definition of precondition-based slice, but in the method used to compute these slices.</p><p>To illustrate this we consider again Program 7, and compute a precondition-based slice with respect to x x 0 ∧ y y 0 , followed by a postcondition-based slice with respect to the strong postcondition spost(S , x x 0 ∧ y y 0 ). We saw before that the first step is unable to remove any statements in this example. The calculated postcondition is Q spost(S , x x 0 ∧ y y 0 ) ≡ x y 0 * 2 ∧ y y 0 We now calculate weak preconditions using the above as postcondition:</p><formula xml:id="formula_22">wprec 2 (S , Q) y * 2 y 0 * 2 ∧ y y 0 , wprec 1 (S , Q) y * 2 y 0 * 2 ∧ y y 0 Now since | wprec 1 (S , Q) → wprec 2 (S , Q),</formula><p>the statement in line 1 can indeed be removed, as would be expected.</p><p>This example motivates the following: henceforth in this paper we will concentrate on methods for calculating specification-based slices. Whenever the specification consists of a precondition (resp. postcondition) only, it will be completed by computing the strong postcondition (resp. weak precondition) of the program with respect to it. Computing precondition or postcondition-based slices as special cases of specification-based slices allows for a more precise identification of removable statements.</p><p>Program 8 is a further example of a precondition-based slice that will be calculated as a specification-based slice, following the ideas outlined above (it is taken from <ref type="bibr" target="#b6">[CCL98]</ref>, see Sect. 3.5). The idea is to slice this program with respect to the precondition a &gt; 0. Clearly the else branch is dead, and if it was not already skip it would be replaced by skip in the computed slice, since it will not be executed with this precondition. The goal here is to illustrate something else: since the then branch will be executed, the first statement in the program will not produce any effect, since the final value of x will be given by the statement in line 3. It is thus a dead statement that should be eliminated.</p><p>Let S be the above program and P be x x 0 ∧ y y 0 ∧ z z 0 ∧ a a 0 ∧ a &gt; 0. In order to eliminate redundant code we will calculate a slice of this program with respect to the specification (P , spost(S , P )). We start by propagating the precondition forward using strong postcondition calculations, and then propagate backward the strong postcondition, using weak precondition calculations. This is shown in Fig. <ref type="figure" target="#fig_6">3</ref>, in which we also simplify the calculated assertions to equivalent formulas. Clearly | spost 0 (S , P ) → spost 1 (S , P ), but | wprec 1 (S , P ) → wprec 2 (S , P ), thus the first command in the program can be eliminated.</p><p>Design by contract and specification-based slicing It may be useful to apply specification-based slicing to code already annotated with specifications, following the principles of design by contract-a software development approach that advocates specifying the behavior of program routines through the use of annotations, and checking them individually (either statically or dynamically) to obtain globally correct programs. For code that has been developed in this way, it is cheap to apply specification-based slicing techniques, based on the specification information that is already present in the code.</p><p>A first application in this context is again the elimination of unnecessary code. A piece of software that has already been proven correct with respect to a specification may well contain code that is not actually playing any useful role regarding that specification. This unnecessary code that may have been introduced during development is not detected by the verification process itself, but slicing the program with respect to the proven specification will hopefully remove such code.</p><p>A different application is concerned with code that has been verified but is now being used in a specialized context, i.e. the specification that is required for a given use of the code is actually weaker (because a stronger precondition is present, and/or a weaker postcondition is required) than the proven specification. A typical situation is software reuse. Think for instance of a library containing a procedure that implements a traversal of some data structure, and collects a substantial amount of information in that traversal. It may be the case that for a given project one wants to reuse this procedure without requiring all the information collected in the traversal. In this case the procedure will be invoked with a weaker specification, and it makes sense to produce a specialized version to be included in the current project. A specification-based slice can be computed to this effect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Properties of assertion-based slicing</head><p>In abstract terms, given a program S C 1 ; . . . ; C n with specification (P , Q), an assertion-based slicing algorithm must be able to 1. Identify subprograms that could be removed from the program being sliced, while preserving its correctness with respect to a given specification. More concretely, the algorithm must decide for every i , j if remove(i , j , S ) (P ,Q) S holds, and then proceed recursively to identify removable subprograms of each C i . 2. Select, among the set of statements identified as removable, the combination (or one of the combinations) that results in the best slice according to some criterion (the most obvious is the smallest number of program lines). Although this has been considered more seriously in the work of Comuzzi and colleagues on postcondition-based slicing, it applies to all three forms of slicing we have considered.</p><p>This section is devoted to point 1; the second point will be considered in Sect. 7. The currently available algorithms for precondition-based and postcondition-based slicing check the validity of a formula relating the propagated conditions near the statements i and j . This seemed to be a good test of whether the sequence of commands between i and j could be removed, but in Sect. 4 it was shown that for precondition-based slicing the method used in previous work fails to identify statements that should be removed because they do not contribute to the final state of the program, in any of the executions specified by the precondition. The failure occurs when the commands are made irrelevant by other instructions that occur later in the program, and thus cannot be detected by the prescribed method. The bottom line is that using Lemma 4 to design precondition or postcondition-based slicing algorithms is in fact misleading. The problem can be solved by simply observing our definition of these slices (Definition 2), which are given as particular cases of specification-based slices. For instance given a precondition P , it suffices to calculate the strong postcondition of the program with respect to P and then calculate a specification-based slice of S with respect to (P , spost(S , P )). For specification-based slicing, the algorithm of <ref type="bibr" target="#b8">[CLYK01]</ref> considers sequentially the propagation of preconditions and postconditions. But in Sect. 3.3 we have already shown that first slicing with preconditions and later with postconditions (or vice versa) may fail to remove statements which can be removed, according to the definition. We will now see that using preconditions and postconditions simultaneously allows for a precise identification of removable statements.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.">Removable commands</head><p>We start by generalizing Lemma 1. This lemma states that there exist two equivalent ways to calculate verification conditions for a given program and specification: one based on weak preconditions and another based on strong postconditions. We will now see that for a given program this can be generalized: one can equally generate verification conditions by breaking the sequence of commands at any point, resulting in a prefix and a suffix of the initial command. The set of verification conditions is given as the union of the verification conditions of the suffix (computed using weak preconditions) and of the prefix (using strong postconditions). An additional verification condition relates the strong postcondition of the prefix and the weak precondition of the suffix. The first point in the following lemma formalizes this idea:</p><p>Lemma 5 Let (P , Q) be a specification and S C 1 ; . . . ; C n a program.</p><formula xml:id="formula_23">1. | VCG w (P , S , Q) iff | VC s [k ](S , P ), spost k (S , P ) → wprec k +1 (S , Q), VC w [k + 1](S , Q), for k ∈ {0, . . . , n} 2. If C k if b then S t else S f for some k ∈ {1, . . . , n}, then | VCG w (P , S , Q) iff | VC s [k − 1](S , P ), VCG w (spost k −1 (S , P ) ∧ b, S t , wprec k +1 (S , Q)), VCG w (spost k −1 (S , P ) ∧ ¬b, S f , wprec k +1 (S , Q)), VC w [k + 1](S , Q) 3. If C k while b do {I } S b for some k ∈ {1, . . . , n}, then | VCG w (P , S , Q) iff | VC s [k − 1](S , P ), spost k −1 (S , P ) → I , VCG w (I ∧ b, S b , I ), I ∧ ¬b → wprec k +1 (S , Q), VC w [k + 1](S , Q) Proof 1.</formula><p>Applying repeatedly the definitions of wprec, VC w , spost, VC s , and Lemma 1:</p><formula xml:id="formula_24">| P → wprec(S , Q), VC w (S , Q) iff | P → wprec(C 1 , wprec(C 2 ; . . . ; C n , Q)), VC w (C 1 , wprec(C 2 ; . . . ; C n , Q)), VC w (C 2 ; . . . ; C n , Q) iff | VC s (C 1 , P ), spost(C 1 , P ) → wprec(C 2 ; . . . ; C n , Q), VC w (C 2 ; . . . ; C n , Q) iff | VC s (C 1 , P ), spost(C 1 , P ) → wprec(C 2 , wprec(C 3 ; . . . ; C n , Q)), VC w (C 2 , wprec(C 3 ; . . . ; C n , Q)), VC w (C 3 ; . . . ; C n , Q) iff | VC s (C 1 , P ), VC s (C 2 , spost(C 1 , P )), spost(C 2 , spost(C 1 , P )) → wprec(C 3 ; . . . ; C n , Q), VC w (C 3 ; . . . ; C n , Q) iff | VC s (C 1 ; C 2 , P ), spost(C 1 ; C 2 , P ) → wprec(C 3 ; . . . ; C n , Q), VC w (C 3 ; . . . ; C n , Q) . . . iff | VC s (C 1 ; . . . ; C k , P ), spost(C 1 ; . . . ; C k , P ) → wprec(C k +1 ; . . . ; C n , Q), VC w (C k +1 ; . . . ; C n , Q)</formula><p>2. Using the definition of the VCGen and Lemma 5 (1), one has the following</p><formula xml:id="formula_25">| VCG w (P , S , Q) iff | VC s [k − 1](S , P ), spost k −1 (S , P ) → wprec k (S , Q), VC w [k ](S , Q) iff | VC s [k − 1](S , P ), spost k −1 (S , P ) → (b → wprec(S t , wprec k +1 (S , Q))) ∧ (¬b → wprec(S f , wprec k +1 (S , Q))), VC w (S t , wprec k +1 (S , Q)), VC w (S f , wprec k +1 (S , Q)), VC w [k + 1](S , Q) iff | VC s [k − 1](S , P ), spost k −1 (S , P ) ∧ b → wprec(S t , wprec k +1 (S , Q)), VC w (S t , wprec k +1 (S , Q)), spost k −1 (S , P ) ∧ ¬b → wprec(S f , wprec k +1 (S , Q)), VC w (S f , wprec k +1 (S , Q)), VC w [k + 1](S , Q) iff | VC s [k − 1](S , P ), VCG w (spost k −1 (S , P ) ∧ b, S t , wprec k +1 (S , Q)), VCG w (spost k −1 (S , P ) ∧ ¬b, S f , wprec k +1 (S , Q)), VC w [k + 1](S , Q)</formula><p>3. We reason as follows, again using the definition of the VCGen and Lemma 5 (1)</p><formula xml:id="formula_26">| VCG w (P , S , Q) iff | VC s [k − 1](S , P ), spost k −1 (S , P ) → wprec k (S , Q), VC w [k ](S , Q) iff | VC s [k − 1](S , P ), spost k −1 (S , P ) → I , I ∧ b → wprec(S b , I ), I ∧ ¬b → wprec k +1 (S , Q), VC w (S b , I ), VC w [k + 1](S , Q) iff | VC s [k − 1](S , P ), spost k −1 (S , P ) → I , VCG w (I ∧ b, S b , I ), I ∧ ¬b → wprec k +1 (S , Q), VC w [k + 1](S , Q)</formula><p>The significance of the first point of this lemma is that, according to the following proposition, it can be decided when the sequence C i ; . . . ; C j can be removed by considering the prefix C 1 ; . . . ; C i−1 and the suffix C j +1 ; . . . ; C n .</p><p>Proposition 1 Let (P , Q) be a specification, S C 1 ; . . . ; C n a program, and i , j , integers such that 1 ≤ i ≤ j ≤ n.</p><formula xml:id="formula_27">If | spost i−1 (S , P ) → wprec j +1 (S , Q) then remove(i , j , S ) (P ,Q) S</formula><p>Proof remove(i , j , S ) is clearly a portion of S . Now let us assume that | VCG w (P , S , Q); we need to prove that | VCG w (P , remove(i , j , S ), Q). Applying Lemma 5 (1) to S with k i − 1 and k j we get respectively: <ref type="figure">, Q</ref>). Now it suffices to apply Lemma 5 (1) to the program remove(i , j , S ) with k i − 1. Since remove(i , j , S ) C 1 ; . . . ; C i−1 ; C j +1 ; . . . ; C n , this yields the following, which we apply from right to left.</p><formula xml:id="formula_28">| VCG w (P , S , Q) iff | VC s [i − 1](S , P ), spost i−1 (S , P ) → wprec i (S , Q), VC w [i ](S , Q) | VCG w (P , S , Q) iff | VC s [j ](S , P ), spost j (S , P ) → wprec j +1 (S , Q), VC w [j + 1](S , Q) Thus | VC s [i − 1](S , P ) and | VC w [j + 1](S</formula><formula xml:id="formula_29">| VCG w (P, remove(i, j , S ), Q) iff | VC s [i − 1](S , P ), spost i−1 (S , P ) → wprec j +1 (S , Q), VC w [j + 1](S , Q)</formula><p>We remark that since | VCG w (P , S , Q) implies | spost i−1 (S , P ) → wprec i (S , Q) and | spost j (S , P ) → wprec j +1 (S , Q), the following also hold:</p><formula xml:id="formula_30">If | wprec i (S , Q) → wprec j +1 (S , Q) then remove(i , j , S ) (P ,Q) S (1) If | spost i−1 (S , P ) → spost j (S , P ) then remove(i , j , S ) (P ,Q) S (2)</formula><p>However, note that the latter conditions are both stronger than the one in the proposition, which means that using them as tests could fail to identify some removable subprograms. This is in accordance with the examples in Sect. 3, which have shown that simply propagating P forward and Q backward, and checking for implications between the propagated spost k (S , P ) and then for implications between the propagated wprec k (S , Q), while sound, might result in slices that are not minimal. The method proposed in the literature calculates slices using these stronger tests, and this is the reason why they fail, for instance in Program 6. To illustrate our point with the latter program it suffices to note that since | spost 2 (S , P ) → wprec 4 (S , Q), the command C 3 can be removed according to the test of Proposition 1. Proposition 1 in fact provides us with the weakest condition for slicing programs, since if we assume the initial program to be correct with respect to the given specification the reverse implication also holds:</p><formula xml:id="formula_31">Proposition 2 Let (P , Q) be a specification, S C 1 ; . . . ; C n a program such that | VCG w (P , S , Q), and i , j , integers such that 1 ≤ i ≤ j ≤ n. If remove(i , j , S ) (P ,Q) S then | spost i−1 (S , P ) → wprec j +1 (S , Q)</formula><p>Proof It suffices to prove that VCG w (P , remove(i , j , S ), Q) implies | spost i−1 (S , P ) → wprec j +1 (S , Q). Again applying Lemma 5 (1) to remove(i , j , S ) with k i − 1 yields the following, which we now apply from left to right.</p><formula xml:id="formula_32">| VCG w (P, remove(i, j , S ), Q) iff | VC s [i − 1](S , P ), spost i−1 (S , P ) → wprec j +1 (S , Q), VC w [j + 1](S , Q)</formula><p>This is a guarantee that our test identifies all removable subsequences of commands of a correct program-note that implications (1) and (2) cannot be reversed in this way. Finally, note that the results in this section apply equally in the scope of total correctness and terminationsensitive slicing (the proofs are similar, using Lemma 2 instead of Lemma 1). In particular, Lemma 5 (1) and (2) hold with VCG w t (resp. VC </p><formula xml:id="formula_33">| VCG w t (P, S , Q) iff | VC s t [k − 1](S , P ), spost k −1 (S , P ) → I , I ∧ b → e v ≥ 0, VCG w t (I ∧ b ∧ e v x 0 , S b , I ∧ e v &lt; x 0 ), I ∧ ¬b → wprec k +1 (S , Q), VC w t [k + 1](S , Q)</formula><p>Proposition 1 applies with • (P ,Q) • substituted for • (P ,Q) • (note that removing any subsequence from a terminating sequence of commands cannot result in a non-terminating sequence, so this is not surprising). Proposition 2 also applies, with VCG w t substituted for VCG w .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.">Slicing subprograms</head><p>The conditional branching and loop commands are structurally composed of sequences of commands. We will call these sequences (but not their subsequences) subprograms of the program under consideration. Given a specification (P , Q) for a program, we associate to each of its subprograms a local specification, which is obtained by propagating P and Q.</p><p>Definition 4 (Subprogram and local specification) Let S be a program and (P , Q) a specification for it. We will write ( P , Ŝ , Q) (P , S , Q) with the meaning that Ŝ is a subprogram of S , and moreover given the specification (P , Q) for S the corresponding local specification of Ŝ is ( P , Q). The relation is defined inductively as follows.</p><p>• (P , S , Q) (P , S , Q);</p><formula xml:id="formula_34">• If (P 1 , S 1 , Q 1 ) (P , S , Q) and (P 2 , S 2 , Q 2 ) (P 1 , S 1 , Q 1 ) then (P 2 , S 2 , Q 2 ) (P , S , Q). • If S C 1 ; . . . ; C n and C i if b then S t else S f for some i with 1 ≤ i ≤ n, then -(spost i−1 (S , P ) ∧ b, S t , wprec i+1 (S , Q)) (P , S , Q) -(spost i−1 (S , P ) ∧ ¬b, S f , wprec i+1 (S , Q)) (P , S , Q) • If S C 1 ; . . . ; C n and C i while b do {I } S b for some i with 1 ≤ i ≤ n, then (I ∧ b, S b , I ) (P , S , Q).</formula><p>As expected, subprograms of a correct program are correct with respect to their local specifications.</p><p>Lemma 6 Let S , Ŝ be programs and (P , Q) a specification such that ( P , Ŝ , Q) </p><formula xml:id="formula_35">(P , S , Q), i.e. Ŝ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ŝ</head><p>Proof (1) Clearly S must be a portion of S . The refinement aspect is proved by induction on the definition of as follows.</p><p>• If Ŝ S the result holds trivially, with S Ŝ .</p><p>• Let (P 1 , S 1 , Q 1 ) (P , S , Q) and ( P , Ŝ , Q) (P 1 , S 1 , Q 1 ). Moreover let S 1 be the program that results from replacing Ŝ by Ŝ in S 1 . Then by induction hypothesis one has that Ŝ ( P, Q) Ŝ implies S 1 (P 1 ,Q 1 ) S 1 . Now let S denote the result of replacing S 1 by S 1 in S . Then again by induction hypothesis one has that S 1 (P 1 ,Q 1 ) S 1 implies S (P ,Q) S . Note that S can also be seen as the result of replacing Ŝ by Ŝ in S , thus we are done since Ŝ ( P, Q) Ŝ implies S (P ,Q) S . • Let S C 1 ; . . . ;C i−1 ; if b then Ŝ else S f ; C i+1 ; . . . ;C n . We assume | VCG w (P , S , Q); using Lemma 5</p><p>(2), this implies</p><formula xml:id="formula_36">| VC s [i − 1](S , P ), VCG w (spost i−1 (S , P ) ∧ b, Ŝ , wprec i+1 (S , Q)), VCG w (spost i−1 (S , P ) ∧ ¬b, S f , wprec i+1 (S , Q)), VC w [i + 1](S , Q)</formula><p>and since Ŝ (spost i−1 (S ,P )∧b,wprec i+1 (S ,Q)) Ŝ , this in turn implies (2) Ŝ is a portion of Ŝ ; for the refinement aspect it suffices to prove that | VCG w (P , S , Q) implies VCG w ( P , Ŝ , Q). Again this is proved by induction on the definition of . We illustrate this for the conditional case, with S C 1 ; . . . ; C i−1 ; if b then Ŝ else S f ; C i+1 ; . . . ; C n . We have by Lemma 5 (2) that</p><formula xml:id="formula_37">| VC s [i − 1](S , P ), VCG w (spost i−1 (S , P ) ∧ b, Ŝ , wprec i+1 (S , Q)), VCG w (spost i−1 (S , P ) ∧ ¬b, S f , wprec i+1 (S , Q)), VC w [i + 1](S ,</formula><formula xml:id="formula_38">| VC s [i − 1](S , P ), VCG w (spost i−1 (S , P ) ∧ b, Ŝ , wprec i+1 (S , Q)), VCG w (spost i−1 (S , P ) ∧ ¬b, S f , wprec i+1 (S , Q)), VC w [i + 1](S , Q)</formula><p>and thus | VCG w (spost i−1 (S , P ) ∧ b, Ŝ , wprec i+1 (S , Q)).</p><p>Recall that terminating programs admit non-terminating programs as specification-based slices, since termination-insensitive slicing merely forces the preservation of the loop invariants. In particular, since skip (I ∧b,I ) S always holds (because | I ∧ b → I ), for any P , Q, and I one has that while b do {I } skip (P ,Q) while b do {I } S . Consequently, any program admits as a slice the program that results from removing the body of every loop.</p><p>Of course, this does not apply in a total correctness setting. Again, if one substitutes</p><formula xml:id="formula_39">• (P ,Q) • for • (P ,Q)</formula><p>• and VCG w t for VCG w , the previous results are valid also in the context of termination-sensitive slicing (the proofs are similar). It suffices to consider an extra case in the definition of subprogram, for loops annotated with variants, as follows:</p><formula xml:id="formula_40">• If S C 1 ; . . . ; C n and C i while b do {I , e v } S b for some i with 1 ≤ i ≤ n, then (I ∧b∧e v x 0 , S b , I ∧e v &lt; x 0 ) (P , S , Q).</formula><p>The proposition can be used to further slice a program by slicing its subprograms with respect to their local specifications. Conditional branches are sliced by propagating the postcondition inside both branches, as well as the precondition strengthened with the boolean condition and its negation, respectively. In the case of a loop with invariant I and condition b, it suffices to use as specification for the body of the loop the assertions (I ∧ b, I ), or (I ∧ b ∧ e v x 0 , I ∧ e v &lt; x 0 ) for termination-sensitive slicing.</p><p>This can be of use in two scenarios mentioned in Sect. 4. If the program is being sliced to remove redundant code, using a specification with respect to which it has been proved correct, then the loop annotations were adequate to prove correctness, and the proposition allows the removal of redundant code to proceed inside loops (each loop body can be sliced with respect to the preservation of its invariant and the strict decrease of its variant).</p><p>In a specialization / reuse scenario, the program is being sliced based on a weaker specification than the one with respect to which it was originally proved correct. In this scenario, it may well be the case that the loop invariants annotated in the program are stronger than they need to be-they have been used to establish correctness with respect to a stronger specification than the one now being used. In order to allow the slicing process to proceed usefully inside loop bodies, the user should first replace the invariants by weaker versions that are sufficient for proving correctness with respect to the new specification, and only then use Proposition 3 to slice the loop bodies with these weaker invariants.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Slicing criterion</head><p>The above discussion raises a question concerning the criterion to be used for comparing the quality of different slices of the same program. The criterion that was implicit in Sect. 3 considered the total number of commands or lines of code in a slice. Note that for programs consisting only of atomic commands (i.e. for sequences of skip and assignment commands) the number of commands and lines (assuming one command per line) are the same. In the presence of commands containing subprograms however, this is not so, since our program syntax dictates that a loop or a conditional is a single command, regardless of the length of their body / branch subprograms. A more appropriate measure (i.e. closer to the notion of "lines of code") is the number of atomic commands and boolean conditions.</p><p>Based on this criterion, selecting the minimal slice of a given program S C 1 ; . . . ;C n implies taking into consideration the number of commands and boolean conditions of each subprogram Ŝ of S -it makes no sense to just count the number (between 1 and n) of top-level commands in each slice of S . Moreover, since each Ŝ can be sliced with respect to its local specification following Proposition 3, the general structure of a slicing algorithm should be to slice S only after slicing each of its subprograms with respect to its local specification. Only then can the minimal slice of S be selected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3.">Intermediate conditions</head><p>A major difference between the notions of slicing based on assertions and traditional notions based on dependencies is that in the latter the slicing criterion always includes a line number k ; in forward slicing one asks for instructions not dependent on the values at line k of a given set of variables to be removed; in backward slicing it is the instructions on which the values of the variables at line k do not depend that are removed.</p><p>This can be mimicked in our context by introducing an intermediate assertion to be taken into account for calculating a slice. We briefly explain here how our framework can be extended in this direction. Naturally, such slices are particular cases of specification-based slices-the intermediate assertion simply restricts the definition further with respect to the specification. The following lemma is straightforward to prove using Lemma 5 (1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 7 If S</head><formula xml:id="formula_41">(P ,R,k ,Q) S then S (P ,Q) S .</formula><p>Intermediate assertions can be used with the practical goal of facilitating automatic proofs by inserting conditions that are obviously true at the given line, which may allow more commands to be sliced off. But they also enrich the power of specification-based slicing, allowing one to slice fragments of the code with respect to local conditions, possibly even omitting part of the global specification. An extreme case is to compute a slice consisting of a postcondition-based slice of a prefix of a program, followed by a precondition-based slice of a suffix, as in S (wprec(C 1 ;... ;C k ,R),R,k ,spost(C k +1 ;... ;C n ,R)) S . In this case the intermediate condition is the only slicing criterion considered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Labeled control flow graphs</head><p>In Sect. 3 we have shown that the quadratic time algorithms-even our improved version, which always eliminates the longest contiguous subsequence of S -do not produce minimal slices. In Sect. 7 we will show that the problem of selecting commands to be removed from a program in order to produce a minimal slice can be formulated as a graph problem, and solved using standard graph algorithms. In this section we set up a basis for this, by defining a notion of assertion-labeled control flow graph of a program with respect to a given specification. Definition 6 (Labeled control flow graph) Given a program S , precondition P and postcondition Q such that S C 1 ; . . . ; C n , the labeled control flow graph LCFG(S , P , Q) of S with respect to (P , Q) is a labeled directed acyclic graph (DAG) whose edge labels are pairs of logical assertions on program states. To each command C in program S we associate its input node IN(C ) and its ouput node OUT(C ) in the graph LCFG(S , P , Q). The graph is constructed as follows:</p><p>1. Each command C i in S will be represented by one (in the case of skip and assignment commands) or two nodes (for conditional and loop commands).</p><p>• If C i is skip or an assignment command, let there be a new node C i in the graph. We set </p><formula xml:id="formula_42">IN(C i ) OUT(C i ) C i . • If C i if b then S t else S f ,</formula><formula xml:id="formula_43">LCFG(S , I ∧ b ∧ e v x 0 , I ∧ e v &lt; x 0 )</formula><p>This graph is grafted into the present graph by removing its START node and setting the origin of the dangling edge to be the node IN(C i ), and similarly removing its END node and setting the destination of the dangling edge to be the node OUT(C i ).</p><p>Clearly every subprogram Ŝ of S is represented by a subgraph of LCFG(S , P , Q) delimited by a pair of nodes START/END, i f / f i, or do/od. Let us denote these nodes respectively by IN( Ŝ ) and OUT( Ŝ ). The basic intuition of labeled CFGs is that for every pair of consecutive commands Ĉi , Ĉi+1 in Ŝ , there exists an edge ( Ĉi , Ĉi+1 ) in LCFG(S , P , Q) whose label consists of the strong postcondition of the prefix of Ŝ ending with Ĉi , and the weak precondition of the suffix of Ŝ beginning with Ĉi+1 , with respect to the local specification ( P , Q) of Ŝ propagated from (P , Q). If | VCG w ( P , Ŝ , Q) then every edge in the subgraph representing Ŝ has a label (φ, ψ) such that | φ → ψ, as a consequence of Lemma 5 (1). Moreover, by Lemma 6, if | VCG w (P , S , Q) then this must be true for every subprogram Ŝ of S , and thus every edge in the graph LCFG(S , P , Q) has a label (φ, ψ) such that | φ → ψ.</p><p>If loops are annotated with variants, this is taken into account when constructing the subgraph corresponding to the loop's body (point 5 of the definition). So we now have that | VCG w t (P , S , Q) implies | φ → ψ for every label (φ, ψ) in the graph.</p><p>Finally, we remark that the LCFG of a program can be constructed in three steps by first building the unlabeled CFG from the syntax tree of the program; then assigning the first component of the labels by traversing the graph from START to END; and finally assigning the second component by traversing the graph in the reverse direction. In each of these traversals the label of each edge can be calculated locally from the labels of the (one or two) previous edges. In particular, for 1 ≤ k ≤ n we have spost k (S , P ) spost(C k , spost k −1 (S , P )) and wprec k (S , Q) wprec(C k , wprec k +1 (S , Q)). Note however that the cost of constructing the graph is not linear on the program size, since weak preconditions are potentially of exponential size on the length of the program (but this can be corrected to quadratic, see Sect. 8).</p><p>In this paper, labeled control flow graphs are used as a basis for the definition of slice graphs in the next section. We observe however that they are interesting entities on their own; in [dCHP] we explore their application for the interactive generation of verification conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Slice graphs</head><p>We will now define a notion of slice graph, in which removable sequences of commands are associated with edges added to the initial control flow graph.</p><p>Definition 7 (Slice graph) Consider a program S and a specification (P , Q) such that | VCG w (P , S , Q) (in which case we assume loops are not annotated with variants) or | VCG w t (P , S , Q). The slice graph SLCG(S , P , Q) of S with respect to (P , Q) is obtained from the labeled control flow graph LCFG(S , P , Q) by inserting additional edges as follows.</p><p>For every subprogram Ŝ Ĉ1 ; . . . ; Ĉn , with ( P , Ŝ , Q) (P , S , Q), is inserted; • For all i , j ∈{1, . . . , n} such that i &lt; j , if | spost i−1 ( Ŝ , P ) → wprec j +1 ( Ŝ , Q), an edge (OUT( Ĉi−1 ), IN( Ĉj+1 ))</p><formula xml:id="formula_44">• If | P → Q, a</formula><p>with label (spost i−1 ( Ŝ , P ), wprec j +1 ( Ŝ , Q)) is inserted;</p><p>Note that this construction is purely based on the LCFG of S : P , Q, spost i−1 ( Ŝ , P ), and wprec j +1 ( Ŝ , Q) can be read from labels of edges in the subgraph corresponding to the subprogram being considered. For each subprogram, first-order conditions are generated for every pair of edges such that the first precedes the second in the graph (the order in which this is done is irrelevant). If the validity of some condition cannot be established, the corresponding edge will not be added to the graph, in accordance with the requirement that slicing must be conservative.</p><p>As an example, Fig. <ref type="figure" target="#fig_9">4</ref> partially shows the slice graph for Program 5 with respect to the specification (y &gt; 10, x ≥ 0). Removable sequences are signaled by the thick edges (and one skip node) that are added to the initial labeled CFG. Many edges are omitted to lighten the presentation of the graph; two edges are missing in the then branch (from x : 100 to x : x − 100 and from x : x + 50 to f i), and in the else branch five edges are missing-note that since the first component of every label in this path is a contradiction, an edge is inserted from each node to every reachable node in the else branch).</p><p>For any given subprogram Ŝ of S , the slice graph contains as subgraph the LCFG of every slice of Ŝ with respect to its local specification, and consequently also the LCFG of the program that results from replacing in S any subprogram by one if its slices. The following result formalizes this fact.</p><p>Lemma 8 In the conditions of Definition 7, let i , j be integers such that 1 ≤ i ≤ j ≤ n, and S the program resulting from replacing Ŝ by remove(i , j , Ŝ ). Then 1. If | VCG w (P , S , Q), remove(i , j , Ŝ ) ( P, Q) Ŝ iff the graph LCFG(S , P , Q) is a subgraph of SLCG(S , P , Q).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">If | VCG w</head><p>t (P , S , Q), remove(i , j , Ŝ ) ( P, Q) Ŝ iff the graph LCFG(S , P , Q) is a subgraph of SLCG(S , P , Q).</p><p>Proof We prove 1 (the proof of 2 is similar, since Propositions 1 and 2 also apply for termination-sensitive slicing, as explained at the end of Sect. 5.1). (Only if part) By Proposition 2, | spost i−1 ( Ŝ , P ) → wprec j +1 ( Ŝ , Q). Clearly the graph LCFG(S , P , Q) is equal to LCFG(S , P , Q), with the exception of a subgraph that is no longer present, and is replaced by an edge (or two edges and a skip node). Moreover these new edges are present in the graph SLCG(S , P , Q), following Definition 7. Conditional commands pose a more substantial problem. Simply applying a shortest paths algorithm would select one of the branches of the conditional; what is required is to slice both branches with respect to their local specifications, and then take into account the total number of lines of code of both branches, when slicing the sequence of commands containing this conditional. We sketch one way to do this combining a weighted shortest paths algorithm with graph rewriting, as follows:</p><p>1. Assign a weight of 1 to every edge of the slice graph G. 2. For all conditional commands that do not contain any conditional commands as subprograms, (i) run a shortest paths algorithm on the subgraphs of G corresponding to both branches of the conditional, and let x 1 + l + r , where l and r are the sum of the weights of the resulting paths in the then and else branch respectively;</p><p>(ii) replace both these subgraphs by a single edge with origin i f and destination f i, with weight x ;</p><p>3. More conditional commands containing no branching in their subprogram graphs may now have been created; repeat from step 2.</p><p>Some mechanism must additionally be used to keep track of the rewritten subgraphs, to allow the slice to be read back from the final graph. Finally, note that the notion of minimality implicit in this discussion is relative, since it is meant with respect to a slice graph: the proof tool may have failed or timed out in checking some valid condition, and thus an edge that should have been included in the graph is missing; the resulting slice will only be as good as the graph. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Intermediate assertions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Conclusion</head><p>Our online laboratory [dCHP10] incorporates all the slicing algorithms discussed in Sect. 3, as well as our algorithm based on slice graphs. <ref type="foot" target="#foot_5">5</ref> The laboratory can also be used for program verification; in particular it allows the user to generate verification conditions in an interactive way and includes visualization capabilities, see <ref type="bibr">[dCHP]</ref>. The latter paper also shows that the notion of control flow graph labeled with semantic information is of independent interest for program verification.</p><p>While the front-end is meant to allow for experimentation and comparison of different algorithms, one obligatory step will be to calculate weak preconditions using Flanagan and Saxe's algorithm <ref type="bibr" target="#b14">[FS01]</ref>, which avoids the potential exponential explosion in the size of the conditions generated, keeping our algorithm within quadratic time. We intend also to explore alternatives to strong postcondition calculations, to eliminate the use of existential quantifiers. One such alternative is the notion of update, as used prominently in the dynamic logic of the KeY system [ABB + 05].</p><p>In future work we intend to construct a slicer for an intermediate verification language like BoogiePL [BCD + 05]. This is a language used by a number of different verification tools for realistic languages, which are first translated into the intermediate language to take advantage of a common VCGen. We foresee that a slicer for this language could very easily cope with code of the different high-level languages that can be translated into it.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>Fig. 1. Language syntax and verification conditions. Q[e/x ] denotes the substitutions of e for x in Q; I is a loop invariant</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 1 (</head><label>1</label><figDesc>Portion-of relation) The • • relation is the reflexive transitive closure of the relation generated by the set of axioms and rules given in Fig. 2. Note that since Fig. 2 defines an anti-symmetric relation, • • is a partial-order. As will be shortly seen, slices of a program S are portions of S that satisfy additional constraints. § x := x +100; x := x+50; x := x−100 ¦ ¥ Program 1: Example for postcondition-based slicing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>Example for precondition-based slicingAs an example of a precondition-based slice, consider now Program 3, and the precondition P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Example for specification-based slicing § x := x * x ; x := x +100; x := x+50 ¦ ¥ Program 6: Example for specification-based slicing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Example for dead code elimination by precondition-based slicing</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>Example for redundant code elimination by specification-based slicing Since | spost 0 (S , x</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Propagated conditions for Program 8</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>for VCG w (resp. VC w , VC s ). (3) is stated as follows: if C k while b do {I , e v } S b for some k ∈ {1, . . . , n}, then</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>new skip node is inserted in the graph, together with two edges (IN( Ŝ ), skip) and (skip, OUT( Ŝ )), both with label ( P , Q).• For all j ∈ {1, . . . , n} if | P → wprec j +1 ( Ŝ , Q), an edge (IN( Ŝ ), IN( Ĉj+1 )) with label ( P , wprec j +1 ( Ŝ , Q)) is inserted; • For all i ∈{1, . . . , n}, if | spost i−1 ( Ŝ , P ) → Q, an edge (OUT( Ĉi−1 ), OUT( Ŝ )) with label (spost i−1 ( Ŝ , P ), Q)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 4 .</head><label>4</label><figDesc>Fig. 4. Example slice graph (extract). Thick lines represent edges that were added to the initial CFG, corresponding to "shortcut" subprograms that do not modify the semantics of the program. These paths have the same origin and destination nodes as other longer paths corresponding to removable sequences</figDesc><graphic coords="29,157.81,91.16,283.72,331.48" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><label></label><figDesc>Computing slices in the presence of intermediate assertions as introduced in Sect. 5.3 requires no major modifications in our setting. It suffices to locate in the slice graph the edge (C k , C k +1 ) with label (φ, ψ), and replace it by two new edges (C k , N ew) and (N ew, C k +1 ) with labels (φ, R) and (R, ψ) respectively, where N ew is a new node inserted in the graph. The standard algorithm will then compute a slice taking the intermediate condition into consideration.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0"><head></head><label></label><figDesc></figDesc><graphic coords="30,197.47,91.28,198.76,268.36" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>), which is valid, and VCG s (P , S , spost (S , P )) spost(S , P ) → spost(S , P ). Thus | VCG s (P , S , spost(S , P )) implies | VCG s (P , S , spost(S , P )) and by Lemma 1 we have that | VCG w (P , S , spost(S , P )) implies | VCG w (P , S , spost(S , P )) 2. Similar to 1.</figDesc><table><row><cell>Lemma 4 Let S be a program containing no loops. Then</cell></row><row><cell>1. If S</cell></row></table><note>S and | spost(S , P ) → spost(S , P ), then S (P ,spost(S ,P )) S . 2. if S S and | wprec(S , Q) → wprec(S , Q), then S (wprec(S ,Q),Q) S Proof 1. Note that VCG s (P , S , spost(S , P )) spost(S , P ) → spost(S , P</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Definition 3 (Termination-sensitive assertion-based slices) Let S be a program and (P , Q) a specification consisting of precondition P and postcondition Q. The program S is said to be • a termination-sensitive specification-based slice of S with respect to (P , Q), written S (P ,Q) S , if S</figDesc><table><row><cell>S and</cell></row><row><cell>moreover</cell></row><row><cell>| VCG w</cell></row></table><note>t (P , S , Q) implies | VCG w t (P , S , Q) • a termination-sensitive precondition-based slice of S with respect to P if S (P ,spost(S ,P )) S ; • a termination-sensitive postcondition-based slice of S with respect to</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>is a subprogram of S with local specification ( P , Q). If | VCG w (P , S , Q) then | VCG w ( P , Ŝ , Q). Proof By induction on the definition of the relation. The first two cases are trivial. If S C 1 ; . . . ; C n and C i if b then S t else S f for some i ∈ {1, . . . , n}, Lemma 5 (2) yields | VCG w (spost i−1 (S , P ) ∧ b, S t , wprec i+1 (S , Q)) and | VCG w (spost i−1 (S , P ) ∧ ¬b, S f , wprec i+1 (S , Q)), as desired. Finally, if S C 1 ; . . . ; C n and C i while b do {I } S b for some i ∈ {1, . . . , n}, Lemma 5 (3) yields | VCG w (I ∧ b, S b , I ).Let us now consider how the subprograms of S can be sliced with respect to a specification. The following proposition states that slicing a subprogram of a program with respect to its local specification results in a slice of the program. VCG w (P , S , Q) and S (P ,Q) S then Ŝ</figDesc><table><row><cell cols="3">Proposition 3 Let S , Ŝ be programs such that ( P , Ŝ , Q)</cell><cell>(P , S , Q). Moreover let Ŝ be a portion of Ŝ , i.e.</cell></row><row><cell>Ŝ</cell><cell cols="2">Ŝ , and S the program that results from replacing Ŝ by Ŝ in S .</cell></row><row><cell cols="2">1. If Ŝ</cell><cell>( P, Q) Ŝ then S (P ,Q) S</cell></row><row><cell cols="3">2. If | ( P, Q)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>Now observe that since S C 1 ; . . .; C i−1 ; if b then Ŝ else S f ; C i+1 ; . . . ; C n , again by Lemma 5 (2) one has | VCG w (P , S , Q). The case when Ŝ is the else branch is similar. • Let S C 1 ; . . . ; C i−1 ; while b do {I } Ŝ ; C i+1 ; . . . ; C n . We assume | VCG w (P , S , Q); using Lemma 5 (3), this implies | VC s [i − 1](S , P ), spost i−1 (S , P ) → I , VCG w (I ∧ b, Ŝ , I ), I ∧ ¬b → wprec i+1 (S , Q), VC , P ), spost i−1 (S , P ) → I , VCG w (I ∧ b, Ŝ , I ), I ∧ ¬b → wprec i+1 (S , Q), VC</figDesc><table><row><cell></cell><cell>w [i + 1](S , Q)</cell></row><row><cell cols="2">and since Ŝ (I ∧b,I ) Ŝ , this in turn implies</cell></row><row><cell cols="2">| VC s [i − 1](S w [i + 1](S , Q)</cell></row><row><cell>Now observe that since S</cell><cell>C</cell></row></table><note>Q) 1 ; . . . ; C i−1 ; while b do {I } Ŝ ; C i+1 ; . . . ; C n , again by Lemma 5 (3) one has | VCG w (P , S , Q).</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Definition 5 (Specification-based slice with intermediate condition) Let S C 1 ; . . . ; C n be a program, (P , Q) a specification, and R an assertion such that | spost(C 1; . . . ; C k , P ) → R and | R → wprec(C k +1 ; . . . ; C n , Q).We say that the program S S 1 ; S 2 is a slice of S with respect to the specification (P , Q) and intermediate condition R at position k , writtenS (P ,R,k ,Q) S , if S 1 (P ,R) C 1 ; . . . ; C k and S 2 (R,Q) C k +1 ; . . . ; C nAlthough Definition 5 is sufficient to illustrate the idea, it can be generalized so that the intermediate condition regards some subprogram of S . Multiple intermediate conditions can also be admitted.</figDesc><table /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head></head><label></label><figDesc>let there be two new nodes i f (b) and f i in the graph. , let there be two new nodes do(b) and od in the graph. We set IN(C i ) do(b) and OUT(C i ) od.2. LetLCFG(S , P , Q) also contain two additional nodes START and END. 3. Let LCFG(S , P , Q) contain an edge (OUT(C i ), IN(C i+1 )) for i ∈ {1, . . . , n − 1}, and two additional edges (START, IN(C 1 )) and (OUT(C n ), END). The labels of these edges are set as follows label (START, IN(C 1 )) (spost 0 (S , P ), wprec 1 (S , Q)) (P , wprec 1 (S , Q)); label (OUT(C i ), IN(C i+1 )) (spost i (S , P ), wprec i+1 (S , Q)) for i ∈ {1, . . . , n − 1}; label (OUT(C n ), END) (spost n (S , P ), wprec n+1 (S , Q)) (spost n (S , P ), Q). 4. For i ∈ {1, . . . , n}, if C i if b then S t else S f , we recursively construct the graphsLCFG(S t , b ∧ spost i−1 (S , P ), wprec i+1 (S , Q)) and LCFG(S f , ¬ b ∧ spost i−1 (S , P ), wprec i+1 (S , Q))These graphs are grafted into the present graph by removing their START nodes and setting the origin of the dangling edges to be in both cases the node IN(C i ), and similarly removing their END nodes and setting the destination of the dangling edges to be the node OUT(C i ).</figDesc><table><row><cell>We set IN(C i ) if (b) and OUT(C i )</cell><cell>f i.</cell></row></table><note>• If C i while b do {I } S or C i while b do {I , e v } S 5. For i ∈ {1, . . . , n}, if C i while b do {I } S , we recursively construct the graph LCFG(S , I ∧ b, I ) If a loop variant is present, with C i while b do {I , e v } S , we construct instead the graph</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">Unlike total correctness, the notion of partial correctness does not require the program to terminate.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" xml:id="foot_1">J. B.Barros et al.   </note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_2">Auxiliary variables are used at the logical level only, and not as program variables.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_3">We remark that when an algorithm is said to run in quadratic time, we are referring to a count of the proof obligations generated to check whether a particular sequence of statements can be eliminated. In order for this to be reflected in an algorithm that actually runs in quadratic time, it is necessary to place a time-out limit for the external automated proof tool; this allows us to consider that proof obligations are discharged in constant time. We leave concrete provers and their usage out of the discussion.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_4">In fact<ref type="bibr" target="#b8">[CLYK01]</ref> advocates replacing the entire conditional command by one of the branches when the other branch is sliced to skip, but it is debatable whether this transformation can still be considered as a form of slicing.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_5">Available from http://gamaepl.di.uminho.pt/gamaslicer.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported by the projects RESCUE (PTDC/EIA/65862/2006), FAVAS (PTDC/EIA-CCO/105034/ 2008), and CROSS (PTDC/EIA-CCO/108995/2008), all funded by Fundac ¸ão para a Ciência e Tecnologia (FCT).</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 5. Example slice graphs</head><p>Proof We prove 1 (the proof of 2 is similar, since Proposition 3 also applies for termination-sensitive slicing, as explained in Sect. 5.2). (Only if part) The slice S is a portion of S , which is obtained by removing some top-level commands of S and doing this recursively for some of the subprograms of S . By Proposition 3 (2), all the commands removed in every subprogram of S must result in slices regarding the local specification of the corresponding subprogram. Consider any sequencing of these subprogram slicing operations; the proof proceeds by induction on the length of this sequence using Lemma 8 (from left to right). (If part) It is clear that in any control-flow graph that is a subgraph of SLCG(S , P , Q), each edge (or pair of edges with a skip node) that is not present in the initial graph LCFG(S , P , Q) has been added relative to a certain subprogram of S and short-circuits some commands in that subprogram. We consider any sequencing of these extra edges; the proof proceeds by induction on the length of this sequence, using Lemma 8 (from right to left) and Proposition 3 (1).</p><p>The slice graph then represents the entire set of specification-based slices of S , and obtaining the minimal slice is simply a matter of selecting the shortest subsequences using the information in the graph.</p><p>Slicing algorithms A consequence of the previous result is that the problem of determining the minimal slice of a given program S with respect to the specification (P , Q) can be reduced to determining the minimal control flow graph contained in the slice graph G SLCG(S , P , Q).</p><p>Consider the case of programs without loops or conditionals, consisting only of atomic commands. Figure <ref type="figure">5</ref> shows the slice graphs for the two problematic examples presented in Sect. 3. It is clear that for such programs the control flow graph of the minimal slice (i.e. the slice containing the smallest number of atomic commands) can be determined by a standard (unweighted) shortest paths algorithm (basically a breadth-first traversal, linear on the size of the graph). This CFG contains of course a single path from START to END.</p><p>For programs containing loops, the same algorithm can be used. Following our remarks on slicing subprograms in Sect. 5, determining a minimal slice of a program implies determining the minimal slices of its subprograms, but from the point of view of slice graphs this is irrelevant: when facing a while loop, the shortest path algorithm will have to cross from the do node to the od node, and will naturally determine the minimal slice of the loop body subprogram.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<author>
			<persName><forename type="first">W</forename><surname>Ahrendt</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Baar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Beckert</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Bubel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Giese</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Hähnle</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Menzel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Mostowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Schlager</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">H</forename><surname>Schmitt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The KeY tool. Softw System Model</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="32" to="54" />
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An overview of JML tools and applications</title>
		<author>
			<persName><forename type="first">L</forename><surname>Burdy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Cheon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">R</forename><surname>Cok</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">D</forename><surname>Ernst</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">R</forename><surname>Kiniry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">T</forename><surname>Leavens</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Poll</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BCC + 05</title>
				<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="212" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Boogie: a modular reusable verifier for objectoriented programs</title>
		<author>
			<persName><forename type="first">M</forename><surname>Barnett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Evan</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B-Y</forename><surname>Deline</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Jacobs</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BCD + 05</title>
		<title level="s">Lecture Notes in Computer Science</title>
		<editor>
			<persName><forename type="first">F</forename><forename type="middle">S</forename><surname>De Boer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Bonsangue</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Graf</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">W</forename><forename type="middle">P</forename><surname>De Roever</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">4111</biblScope>
			<biblScope unit="page" from="364" to="387" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">ACSL: ANSI/ISO C Specification Language</title>
		<author>
			<persName><forename type="first">P</forename><surname>Baudin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Cuoq</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J-C</forename><surname>Filliâtre</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Marché</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Monate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Moy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Prevosto</surname></persName>
		</author>
		<idno>BCF + 10</idno>
		<imprint>
			<date type="published" when="2010">2010</date>
		</imprint>
		<respStmt>
			<orgName>CEA LIST and INRIA</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Assertion-based slicing and slice graphs</title>
		<author>
			<persName><forename type="first">J</forename><surname>Barros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Da Cruz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Henriques</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Pinto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th IEEE international conference on software engineering and formal methods (SEFM&apos;10)</title>
				<editor>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Fiadeiro</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">S</forename><surname>Gnesi</surname></persName>
		</editor>
		<meeting>the 8th IEEE international conference on software engineering and formal methods (SEFM&apos;10)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="93" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">CASSIS: construction and analysis of safe, secure, and interoperable smart devices</title>
		<author>
			<persName><forename type="first">M</forename><surname>Barnett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Rustan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Leino</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><surname>Schulte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="s">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">3362</biblScope>
			<biblScope unit="page" from="49" to="69" />
			<date type="published" when="2004">2004</date>
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
	<note>The Spec# programming system: an overview</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Conditioned program slicing</title>
		<author>
			<persName><forename type="first">G</forename><surname>Canfora</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Cimitile</surname></persName>
		</author>
		<author>
			<persName><forename type="first">De</forename><surname>Lucia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform Softw Technol</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">11-12</biblScope>
			<biblScope unit="page" from="595" to="608" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
	<note>Special issue on program slicing</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Program slicing using weakest preconditions</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">J</forename><surname>Comuzzi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Hart</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FME &apos;96: Proceedings of the third international symposium of formal methods Europe on industrial benefit and advances in formal methods</title>
				<meeting><address><addrLine>London</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="557" to="575" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Program slicing based on specification</title>
		<author>
			<persName><forename type="first">I</forename><forename type="middle">S</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">W</forename><forename type="middle">K</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">S</forename><surname>Yoon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><forename type="middle">R</forename><surname>Kwon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SAC &apos;01: Proceedings of the 2001 ACM symposium on applied computing</title>
				<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="605" to="609" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Verification graphs for programs with contracts</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cruz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Henriques</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Pinto</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
	<note>Submitted for publication</note>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Gamaslicer: an online laboratory for program verification and analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cruz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">R</forename><surname>Henriques</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Pinto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LDTA &apos;10: Proceedings of the tenth workshop on language descriptions, tools and applications</title>
				<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">A discipline of programming</title>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1976">1976</date>
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Backward conditioning: a new program specialisation technique and its application to program comprehension</title>
		<author>
			<persName><forename type="first">C</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Danicic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Hierons</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th international workshop on program comprehension (IWPC&apos;01)</title>
				<meeting>the 9th international workshop on program comprehension (IWPC&apos;01)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="89" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Verification Conditions for source-level imperative programs</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">J</forename><surname>Frade</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">S</forename><surname>Pinto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput Sci Rev</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="252" to="277" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Avoiding exponential explosion: generating compact verification conditions</title>
		<author>
			<persName><forename type="first">C</forename><surname>Flanagan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jb ;</forename><surname>Saxe</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Hierons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Danicic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Howroyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">POPL &apos;01: Proceedings of the 28th ACM SIGPLAN-SIGACT symposium on principles of programming languages</title>
				<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2001">2001. 2001</date>
			<biblScope unit="page" from="138" to="147" />
		</imprint>
	</monogr>
	<note>Proceedings of the IEEE international conference on software maintenance (ICSM&apos;01)</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">An axiomatic basis for computer programming</title>
		<author>
			<persName><forename type="first">Car</forename><surname>Hoare</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun ACM</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="576" to="580" />
			<date type="published" when="1969">1969</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Applying &quot;Design by contract</title>
		<author>
			<persName><forename type="first">B</forename><surname>Meyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput</title>
		<imprint>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Properties of slicing definitions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Ward</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCAM &apos;09: Proceedings of the 2009 ninth IEEE international working conference on source code analysis and manipulation</title>
				<meeting><address><addrLine>Washington</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="23" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Program slicing</title>
		<author>
			<persName><forename type="first">M</forename><surname>Weiser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICSE &apos;81: Proceedings of the 5th international conference on software engineering</title>
				<meeting><address><addrLine>Piscataway</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="1981">1981</date>
			<biblScope unit="page" from="439" to="449" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">A brief survey of program slicing</title>
		<author>
			<persName><forename type="first">B</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Z</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Chen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">XQZ + 05</title>
				<imprint>
			<date type="published" when="2005">2005</date>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1" to="36" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
