<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A scalable t-wise coverage estimator</title>
			</titleStmt>
			<publicationStmt>
				<publisher>ACM</publisher>
				<availability status="unknown"><p>Copyright ACM</p>
				</availability>
				<date type="published" when="2022-05-21">2022-05-21</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Eduard</forename><surname>Baranov</surname></persName>
							<email>eduard.baranov@uclouvain.be</email>
							<affiliation key="aff0">
								<orgName type="institution">Universite catholique de Louvain</orgName>
								<address>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Sourav</forename><surname>Chakraborty</surname></persName>
							<email>sourav@isical.ac.in</email>
							<affiliation key="aff1">
								<orgName type="institution">Indian Statistical Institute India</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Axel</forename><surname>Legay</surname></persName>
							<email>axel.legay@uclouvain.be</email>
							<affiliation key="aff2">
								<orgName type="institution">Universite catholique de Louvain</orgName>
								<address>
									<country key="BE">Belgium</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Kuldeep</forename><forename type="middle">S</forename><surname>Meel</surname></persName>
							<email>meel@comp.nus.edu.sg</email>
							<affiliation key="aff3">
								<orgName type="institution">National University</orgName>
								<address>
									<country>Singapore Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Vinodchandran</forename><forename type="middle">N</forename><surname>Variyam</surname></persName>
							<affiliation key="aff4">
								<orgName type="institution">University of Nebraska-Lincoln</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A scalable t-wise coverage estimator</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 44th International Conference on Software Engineering</title>
						<meeting>the 44th International Conference on Software Engineering						</meeting>
						<imprint>
							<publisher>ACM</publisher>
							<date type="published" when="2022-05-21" />
						</imprint>
					</monogr>
					<idno type="MD5">4085299367DC65A25CD7E6F6AB14BEF9</idno>
					<idno type="DOI">10.1145/3510003.3510218</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2022-12-21T19:37+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Baranov, Eduard</term>
					<term>Chakraborty, Sourav</term>
					<term>Legay, Axel</term>
					<term>Meel, Kuldeep S.</term>
					<term>Variyam, Vinodchandran N Configurable software, ğ‘¡-wise coverage, Approximation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Owing to the pervasiveness of software in our modern lives, software systems have evolved to be highly configurable. Combinatorial testing has emerged as a dominant paradigm for testing highly configurable systems. Often constraints are employed to define the environments where a given system under test (SUT) is expected to work. Therefore, there has been a sustained interest in designing constraint-based test suite generation techniques. A significant goal of test suite generation techniques is to achievewise coverage for higher values of . Therefore, designing scalable techniques that can estimatewise coverage for a given set of tests and/or the estimation of maximum achievable -wise coverage under a given set of constraints is of crucial importance. The existing estimation techniques face significant scalability hurdles. The primary scientific contribution of this work is the design of scalable algorithms with mathematical guarantees to estimate (i) -wise coverage for a given set of tests, and (ii) maximumwise coverage for a given set of constraints. In particular, we design a scalable framework ApproxCov that takes in a test set U, a coverage parameter , a tolerance parameter , and a confidence parameter , and returns an estimate of the -wise coverage of U that is guaranteed to be within (1 Â±)-factor of the ground truth with probability at least 1 âˆ’. We design a scalable framework ApproxMaxCov that, for a given formula F, a coverage parameter, a tolerance parameter , and a confidence parameter , outp...</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>For the past 50 years, software systems have permeated nearly all aspects of our lives, including critical domains such as autonomous driving, criminal sentencing, surveillance, and healthcare. Given the diversity of application scenarios, a software system is designed to be highly configurable to allow widespread adoption <ref type="bibr" target="#b50">[50]</ref>. Economic factors also support the design of highly configurable systems. It is desirable for a software vendor to develop a general-purpose software with a large number of configurations to allow clientlevel customization without necessarily requiring redesign of the underlying software architecture. At the same time, given the usage of software in critical domains such as healthcare, software failures can have serious adverse effects. Therefore, the testing of software systems is of paramount interest.</p><p>A configuration of a system refers to the assignment of values to all the configurable features of the system. Configurability does not come without a price: feature dependencies are common <ref type="bibr" target="#b54">[54]</ref> and could lead to variability bugs appearing only in some configurations. A straightforward testing strategy would be to check whether the system behaves as intended for every possible configuration. However, such an approach is not practical for real-life systems <ref type="bibr" target="#b33">[33]</ref> as it is common to have thousands of features in modern software systems resulting in a prohibitively large number of possible configurations <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5]</ref>. The combinatorial explosion of the possible set of configurations is perhaps best illustrated by the observation that embedded Linux kernel for micro-controllers has over 7.7 Ã— 10 417 configurations <ref type="bibr" target="#b52">[52]</ref>.</p><p>The curse of configuration explosion has been well known for over three decades, and consequently, the area of combinatorial testing has emerged as the dominant paradigm for testing of highly configurable systems <ref type="bibr" target="#b14">[15,</ref><ref type="bibr" target="#b27">27,</ref><ref type="bibr" target="#b34">34,</ref><ref type="bibr" target="#b40">40,</ref><ref type="bibr" target="#b43">43,</ref><ref type="bibr" target="#b47">47,</ref><ref type="bibr" target="#b62">62,</ref><ref type="bibr" target="#b63">63,</ref><ref type="bibr" target="#b68">68]</ref>. The development of combinatorial testing techniques, in large part, has been motivated by the observation that for most systems, interactions among a small number of features are sufficient to trigger the buggy behavior. An influential study by NIST observed that up to 6âˆ’wise, interactions among parameters are responsible for most of the bugs <ref type="bibr" target="#b33">[33]</ref>. Another study showed that discovered variability bugs in Linux kernel involve up to 5âˆ’wise feature interactions <ref type="bibr" target="#b0">[1]</ref>. In combinatorial testing, we are often interested in maximizing ğ‘¡-wise coverage <ref type="foot" target="#foot_0">1</ref> , which measures the fraction of ğ‘¡-sized combinations of features appearing in the test suite over all possible ğ‘¡-sized combinations of features. A test suite that can achieve ğ‘¡-wise coverage of 1 is also called a ğ‘¡-covering array in the literature, i.e., for ğ‘› binary features, a ğ‘¡-covering array U has all the ğ‘› ğ‘¡ 2 ğ‘¡ combinations appearing in itself.</p><p>The complexity of test suite design is exacerbated by the observation that not every configuration is typically allowed by the system, and often constraints are employed to describe the valid set of configurations. In the real world, these constraints represent scenarios for which the systems are expected to work correctly. For example, one of the widely used SPLC challenge benchmark uLinux consists of constraints to capture the variability model in KConfig <ref type="bibr" target="#b52">[52]</ref>. Therefore, given a set of constraints, the possible ğ‘¡-wise combinations of features are defined only over the satisfying assignments of these constraints. At this point, it is perhaps worth emphasizing that even for the case when there are no constraints, the size of a ğ‘¡-covering array for ğ‘› features is Î©(2 ğ‘¡ log ğ‘›) <ref type="bibr" target="#b55">[55]</ref>. The presence of constraints brings additional complications to the design of ğ‘¡-covering array.</p><p>Given the practical importance of the combinatorial testing, the problem of efficient design of the test suite has witnessed a sustained interest for over three decades, evidenced by the diverse set of techniques ranging from evolutionary algorithms <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b37">37]</ref> to constraint-based systems <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b17">17]</ref> proposed over the years. The proposal of these techniques is often accompanied by measurement of ğ‘¡-wise coverage over benchmarks with small ğ‘› as the computation of ğ‘¡-coverage for large values of ğ‘› is considered impractical. Given a test suite U and a set of constraints F over the parameters, the estimation of ğ‘¡-wise coverage requires us to estimate the number of ğ‘¡-combinations of features appearing in the test suite U and the number of possible ğ‘¡-combinations over the solutions of F. For the former computation, the state-of-the-art techniques maintain a hash map of size O ( ğ‘› ğ‘¡ 2 ğ‘¡ ), and the map is updated for every element of U. Furthermore, to compute the possible ğ‘¡-combinations over the solutions of F, the best-known algorithms check whether F conjuncted with a ğ‘¡-combination (expressed as a conjunction of literals) is satisfiable <ref type="foot" target="#foot_1">2</ref> . Unfortunately, for most practical instances, the computation of both the quantities is beyond the reach of the stateof-the-art techniques. The limitations of the current techniques for ğ‘¡-wise coverage estimations are illustrated in reliance on small benchmarks or extremely small-sized test suites whenever comparisons across different test suite generation methodologies are presented. In this context, we ask: Can we design scalable algorithms to closely estimate ğ‘¡-wise coverage with rigorous guarantees?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Our Contribution</head><p>The primary contribution of our work is an affirmative answer to the above question. We design, to the best of our knowledge, the first scalable technique that provides rigorous estimates of ğ‘¡-wise coverage. In particular, we present:</p><p>(1) A to estimate ğ‘¡-wise coverage on configurable systems where each feature can take values from a discrete domain. We demonstrate with experimental evaluation that the generalized algorithms are effective and can provide close estimation of ğ‘¡-wise coverage. Few words are in order to explain the critical enabler for the scalability of ApproxCov and ApproxMaxCov: From our viewpoint, the scalability of ApproxCov owes to the simple but creative usage of the Monte Carlo-based strategy, while for ApproxMaxCov, the reduction to projected model counting allows us to employ and reap the benefits of the recent progress in the development of hashingbased techniques <ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b58">58,</ref><ref type="bibr" target="#b59">59]</ref>. Significance of our contribution: Combinatorial testing is a dominant testing methodology in large and complex software systems. Therefore it is vital to have tools that allow us to compare different test suite generation techniques. Our algorithms ApproxCov and ApproxMaxCov provide the combinatorial testing community sound tools to compare different test suite generation techniques for large benchmarks. As an immediate impact, we expect our techniques to allow a thorough comparison of the recently proposed techniques in CIT community <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b39">39]</ref> for large instances, which was not feasible with the state of the art. The fact that our algorithms are grounded on guarantees that are mathematically proved makes them an attractive toolset in downstream applications. Organization: The rest of the paper is organized as follows. We present notation and preliminaries in Section 2. We present related work in Section 3. We then present the technical contribution of the paper in Section 4: ApproxCov in Section 4.1 and ApproxMaxCov in Section 4.2. In Section 5 we present experimental results over a comprehensive set of benchmarks. Finally, in Section 6, we give concluding remarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">NOTATIONS AND PRELIMINARIES 2.1 Boolean Formulas</head><p>A literal is a Boolean variable or its negation. A clause is a disjunction of a set of literals. A propositional formula F in conjunctive normal form (CNF) is a conjunction of clauses. Vars(F) denotes the set of variables appearing in F. The Vars(F) is also called the support of F. A satisfying assignment or witness of F, denoted by ğœ, is an assignment of truth values to variables in its support such that F evaluates to true. We often represent an assignment by the set of literals that make the variables true. That is, an assignment of True to variable ğ‘¥ is represented as ğ‘¥ and assignment of False to ğ‘¥ is represented as Â¬ğ‘¥. We also use the binary bit 1 (0) to represent True (respectively, False) and binary strings to represent an assignment. We denote the set of all satisfying assignments of F as Sol(F). Given a set of variables ğ‘† âŠ† Vars(F), we use Sol(F) â†“S to denote the projection of Sol(F) on ğ‘†.</p><p>Example. Consider the formula F over 4 variables {ğ‘¥ 1 , ğ‘¥ 2 , ğ‘¥ 3 , ğ‘¥ 4 } given by:</p><formula xml:id="formula_0">F = (ğ‘¥ 1 âˆ¨ ğ‘¥ 3 ) âˆ§ (Â¬ğ‘¥ 1 âˆ¨ Â¬ğ‘¥ 3 ) âˆ§ (ğ‘¥ 1 âˆ¨ Â¬ğ‘¥ 2 ) âˆ§ (ğ‘¥ 3 âˆ¨ Â¬ğ‘¥ 4 ).</formula><p>Sol(F) = {0010, 0011, 1000, 1100}. In the literal representation the assignment 0010 is represented as</p><formula xml:id="formula_1">{Â¬ğ‘¥ 1 , Â¬ğ‘¥ 2 , ğ‘¥ 3 , Â¬ğ‘¥ 4 }. Let ğ‘† = {ğ‘¥ 1 , ğ‘¥ 2 }, then |Sol(F) â†“S | = {00, 10, 11}.</formula><p>The propositional model counting problem is to compute |Sol(F) â†“S | for a given CNF formula F and projection set ğ‘† âŠ† Vars(F). A probably approximately correct (or PAC) counter for Boolean formulas is a probabilistic algorithm that takes as inputs a formula F, a sampling set ğ‘† âŠ† Vars(F), a tolerance parameter ğœ€ âˆˆ (0, 1), and a confidence parameter ğ›¿ âˆˆ (0, 1], and returns a count ğ‘ such that</p><formula xml:id="formula_2">Pr (1 âˆ’ ğœ–)|Sol(F) â†“S | â‰¤ ğ‘ â‰¤ (1 + ğœ€)|Sol(F) â†“S | â‰¥ 1 âˆ’ ğ›¿.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">t-wise Coverage</head><p>The formulation of combinatorial interaction testing (CIT) assigns a variable corresponding to every feature of a software system. While, in practice each feature can take a finite number of values, in the the paper we consider the binary version, where each feature can take two states: True or False. Let ğ‘‹ = {ğ‘¥ 1 , â€¢ â€¢ â€¢ , ğ‘¥ ğ‘› } be the set of all the variables (corresponding to ğ‘› features). Then a configuration ğœ of the system can be represented as an element of the set ğ‘– {ğ‘¥ ğ‘– , Â¬ğ‘¥ ğ‘– }.</p><p>For example, for ğ‘‹ = {ğ‘¥ 1 , ğ‘¥ 2 , ğ‘¥ 3 }, ğœ = {ğ‘¥ 1 , Â¬ğ‘¥ 2 , ğ‘¥ 3 } is an example of a configuration.</p><p>Given a configuration ğœ represented as a set of literals, we define the ğ‘¡-wise coverage of ğœ denoted by Cov t (ğœ) = {ğ‘‡ âŠ† ğœ | |ğ‘‡ | = ğ‘¡ }, the set of all subsets of literals of the size ğ‘¡ in ğœ. Cov t (ğœ) represents the set of ğ‘¡-sized feature combinations due to ğœ. We can extend the notion of Cov t to a set U âŠ† </p><formula xml:id="formula_3">ğ‘– {ğ‘¥ ğ‘– , Â¬ğ‘¥ ğ‘– } of configura- tions as Cov t (U) = ğœ âˆˆU Cov t (ğœ). For a given ğœ, |Cov t (ğœ)| = |ğ‘‹ | ğ‘¡ = ğ‘› ğ‘¡ .</formula><formula xml:id="formula_4">â‰¤ ğ‘¡ â‰¤ |ğ‘‹ |, |ğ‘‹ | ğ‘¡ â‰¤ |Cov t (U)| â‰¤ 2 ğ‘¡ |ğ‘‹ | ğ‘¡ .</formula><p>We will be interested in the coverage of a set of configurations that satisfy certain constraints over the features. We will focus on constraints represented by a Boolean formula F. For a set U âŠ† Sol(F), the ğ‘¡-wise fractional coverage of a set U with respect to a formula F, denoted by FracCov t (U, F) is defined as follows:</p><formula xml:id="formula_5">FracCov t (U, F) = |Cov t (U)| |Cov t (Sol(F))|</formula><p>Example. To illustrate the notions, let us consider again the CNF formula</p><formula xml:id="formula_6">F F = (ğ‘¥ 1 âˆ¨ ğ‘¥ 3 ) âˆ§ (Â¬ğ‘¥ 1 âˆ¨ Â¬ğ‘¥ 3 ) âˆ§ (ğ‘¥ 1 âˆ¨ Â¬ğ‘¥ 2 ) âˆ§ (ğ‘¥ 3 âˆ¨ Â¬ğ‘¥ 4 ).</formula><p>The following table lists Cov t (Sol(F)) for ğ‘¡ = 2. For compactness, we use the bit representation of the assignments and coverage. For example, a set of literals {Â¬ğ‘¥ 1 , Â¬ğ‘¥ 2 } is listed as 00 in the column indexed <ref type="bibr" target="#b0">(1,</ref><ref type="bibr" target="#b1">2)</ref>. </p><formula xml:id="formula_7">|Cov t (Sol(F))| = 17. For ğ‘ˆ = {0010, 0011} (shaded in the table), |Cov t (U)| = 9. FracCov t (U, F) = 9/17.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2-tuples</head><formula xml:id="formula_8">Sol(F) (1, 2) (1, 3) (1, 4) (2, 3) (2, 4) (3,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RELATED WORK 3.1 Combinatorial Testing</head><p>Since the introduction of combinatorial testing in the 1980s as an effective option for configurable systems <ref type="bibr" target="#b40">[40,</ref><ref type="bibr" target="#b62">62]</ref>, steady progress has been reported on this topic. We refer the reader to <ref type="bibr" target="#b34">[34,</ref><ref type="bibr" target="#b47">47,</ref><ref type="bibr" target="#b63">63]</ref> for a detailed overview of the topic. In the classical combinatorial testing, the goal is to design a test suite U such that |Cov t (U)| = ğ‘› ğ‘¡ 2 ğ‘¡ . Such a test suit is also known as a covering array formally defined in <ref type="bibr" target="#b57">[57]</ref>. Covering arrays are orthogonal arrays or matrices with rows representing configurations of a system and every possible t-sized combination of variables appears at least in one column. Over the decades, the construction of covering arrays has witnessed a wide variety of approaches including greedy search <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr" target="#b28">28,</ref><ref type="bibr" target="#b36">36,</ref><ref type="bibr" target="#b37">37,</ref><ref type="bibr" target="#b41">41,</ref><ref type="bibr" target="#b61">61,</ref><ref type="bibr" target="#b65">65,</ref><ref type="bibr" target="#b67">67]</ref>, divide-and-compose <ref type="bibr" target="#b51">[51]</ref>, genetic algorithms <ref type="bibr" target="#b42">[42]</ref>, and tabu search <ref type="bibr" target="#b25">[25,</ref><ref type="bibr" target="#b48">48]</ref>.</p><p>Modern software systems have a large number of features, and the design of covering array is often impractical for ğ‘¡ &gt; 2. Furthermore, the modern softwares have associated variability models, and not every configuration is valid, and therefore, cannot act as a test. In this context, constraints are employed to capture the associated variability models or the scenarios under which a software is expected to behave as per specifications. Combinatorial testing in such a constraint setting is called constrained combinatorial testing <ref type="bibr" target="#b6">[7]</ref>. The presence of constraints has led to the development of techniques that rely on the progress in combinatorial solvers over the past three decades. Several approaches have been proposed that seek to sample solutions subject to constraints. These approaches resulted in BDD-based techniques <ref type="bibr" target="#b35">[35]</ref>, random seeding of DPLL-based SAT solvers <ref type="bibr" target="#b46">[46]</ref>, Markov Chain Monte Carlo-based methods <ref type="bibr" target="#b29">[29]</ref><ref type="bibr" target="#b30">[30]</ref><ref type="bibr" target="#b31">[31]</ref><ref type="bibr" target="#b66">66]</ref>, interval propagation and belief networks-based methods <ref type="bibr" target="#b16">[16,</ref><ref type="bibr" target="#b22">22]</ref>, MaxSAT-based techniques such as Quicksampler <ref type="bibr" target="#b19">[19]</ref>, hashing-based approaches <ref type="bibr" target="#b7">[8,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b58">58]</ref>, knowledge compilation-based approaches such as KUS <ref type="bibr" target="#b56">[56]</ref>, WAPS <ref type="bibr" target="#b26">[26]</ref>, and Baital <ref type="bibr" target="#b2">[3]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Model Counting</head><p>Valiant initiated the complexity theoretic study of model counting and showed that the problem of model counting for CNF formula is #P-complete <ref type="bibr" target="#b64">[64]</ref>. The problem of projected model counting which we employ in this paper is shown to be #â€¢NP-complete <ref type="bibr" target="#b18">[18]</ref>. Given the computational intractability of (projected) model counting, we are often interested in (ğœ€, ğ›¿)-approximations of the exact count, where the goal is to obtain an (1 Â± ğœ–) multiplicative approximation of the exact count with probability at least (1 âˆ’ ğ›¿). Hashing-based techniques have emerged as a dominant paradigm seeking scalability while providing (ğœ€, ğ›¿)-approximation guarantees. The core idea of hashing-based techniques is to employ pairwise independent hash functions to partition the solution space into roughly equal small cells of solutions. Then, we randomly choose one of the small cells, enumerate all the solutions using a SAT solver one by one. The number of solutions is estimated to be simply the number of solutions in the cell multiplied by the total number of cells. The pairwise independent hash functions can be realized using XORbased hash functions. The hashing-based techniques trace their origin to Stockmeyer's seminal work <ref type="bibr" target="#b60">[60]</ref>, subsequently pursued by Gomes, Sabharwal, and Selman <ref type="bibr" target="#b23">[23]</ref>.</p><p>Chakraborty, Meel, and Vardi proposed the first scalable approximate model counter, ApproxMC, which invoked the underlying SAT solver, CryptoMiniSat, O (ğ‘›) times (where ğ‘› is the number of variables in the original formula). Subsequently, Chakraborty et al <ref type="bibr" target="#b10">[11]</ref> reduced the number of SAT calls from O (ğ‘›) to O (log ğ‘›); the corresponding counter was called ApproxMC2. Soos and Meel <ref type="bibr" target="#b59">[59]</ref> sought to improve the underlying SAT solver's architecture; their new architecture, called BIRD, achieved significant performance improvement. ApproxMC is currently in its fourth generation, Ap-proxMC5 <ref type="bibr" target="#b45">[45,</ref><ref type="bibr" target="#b58">58]</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">ğ‘¡-wise Coverage Estimation</head><p>While combinatorial testing has witnessed over four decades of sustained interests from theoreticians and practitioners, the techniques to estimate |Cov U | and |Cov Sol(F) | have rather been largely underexplored. Given a set U, the state of the art technique maintains a map of the ğ‘¡-wise combinations seen in U. In the case of a given formula F, observe that every ğ‘¡-combination can be expressed as a conjunction of ğ‘¡ literals, say ğœ‹. Given such a ğœ‹, the state of the art techniques simply invoke a SAT solver to check whether F âˆ§ ğœ‹ is satisfiable. In our work, we use the implementation of these techniques due to Baranov, Legay, and Meel <ref type="bibr" target="#b2">[3]</ref>, which was used in the evaluation of the current state of the art test generator suite, Baital <ref type="foot" target="#foot_4">5</ref> . We use BLMCov and BLMMaxCov to denote the implementations for computations of Cov t (U) and Cov t (Sol(F)) respectively. To the best of our knowledge, BLMCov and BLMMaxCov represent the current state of the art; an assertion confirmed by the authors of both the recently published studies in SE community <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b39">39]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ALGORITHMS</head><p>In this section we present two algorithms. The first algorithm ApproxCov (presented in Section 4.1) estimates |Cov t (U)|. More precisely ApproxCov takes as input a set U âŠ‚ ğ‘– {ğ‘¥ ğ‘– , Â¬ğ‘¥ ğ‘– }, error parameter 0 &lt; ğœ– &lt; 1, and a confidence parameter 0 &lt; ğ›¿ &lt; 1, and outputs a number that, with probability at least (1 âˆ’ ğ›¿), is between</p><formula xml:id="formula_9">(1 âˆ’ ğœ–)|Cov t (U)| and (1 + ğœ–)|Cov t (U)|.</formula><p>In Section 4.2 we present another algorithm ApproxMaxCov that given a Boolean formula F, estimates |Cov t (Sol(F))|. More precisely, ApproxMaxCov takes as input F, an error parameter 0 &lt; ğœ– &lt; 1 and a confidence parameter 0 &lt; ğ›¿ &lt; 1 and outputs a number that, with probability at least</p><formula xml:id="formula_10">(1 âˆ’ ğ›¿), is between (1 âˆ’ ğœ–)|Cov t (Sol(F))| and (1 + ğœ–)|Cov t (Sol(F))|.</formula><p>Using ApproxCov and ApproxMaxCov we can estimate the value of FracCov t (U, F). Given a Boolean formula F and a set U âŠ‚ Sol(F), say we use ApproxCov(U, ğœ– 1 , ğ›¿ 1 ) and ApproxMaxCov(F, ğœ– 2 , ğ›¿ 2 ) to obtain estimates for |Cov t (U)| and |Cov t (Sol(F))| respectively. Let Out 1 be the output of ApproxCov(U, ğœ– 1 , ğ›¿ 1 ) and Out 2 be the output of ApproxMaxCov(F, ğœ– 2 , ğ›¿ 2 ). So we have with probability at least (1 âˆ’ ğ›¿ 1 ) the following Equation 1 and with probability (1 âˆ’ ğ›¿ 2 ) the Equation 2 holds.</p><formula xml:id="formula_11">(1 âˆ’ ğœ– 1 )|Cov t (U)| â‰¤ Out 1 â‰¤ (1 + ğœ– 1 )|Cov t (U)|,<label>(1)</label></formula><formula xml:id="formula_12">(1 âˆ’ ğœ– 2 )|Cov t (Sol(F))| â‰¤ Out 2 â‰¤ (1 + ğœ– 2 )|Cov t (Sol(F))|.<label>(2)</label></formula><p>So, by union bound, with probability at least (1 âˆ’ ğ›¿ 1 âˆ’ ğ›¿ 2 ) both the above equations work. Thus with probability (1 âˆ’ ğ›¿ 1 âˆ’ ğ›¿ 2 ) we have</p><formula xml:id="formula_13">(1 âˆ’ ğœ– 1 ) (1 + ğœ– 2 ) |Cov t (U)| |Cov t (Sol(F))| â‰¤ Out 1 Out 2 â‰¤ (1 + ğœ– 1 ) (1 âˆ’ ğœ– 2 ) |Cov t (U)| |Cov t (Sol(F))| .<label>(3)</label></formula><p>Thus given a Boolean formula F, a set U âŠ‚ Sol(F), an error parameter ğœ– and a confidence parameter ğ›¿, if we set ğœ– 1 , ğœ– 2 , ğ›¿ 1 and ğ›¿ 2 appropriately we will be able to give an (1 Â± ğœ–)-multiplicative estimate of FracCov t (U, F) with probability (1 âˆ’ ğ›¿). For example, let us set</p><formula xml:id="formula_14">ğœ– 1 = ğœ– 2 = ğœ– 2+ğœ– and ğ›¿ 1 = ğ›¿ 2 = ğ›¿/2. Note that in that case (1+ğœ– 1 )/(1âˆ’ğœ– 2 ) is at most (1+ğœ–) and (1âˆ’ğœ– 1 )/(1+ğœ– 2 ) is at least (1âˆ’ğœ–).</formula><p>Then by using ApproxCov(U, ğœ– 1 , ğ›¿ 1 ) and ApproxMaxCov(F, ğœ– 2 , ğ›¿ 2 ) to estimate |Cov t (U)| and |Cov t (Sol(F))| respectively, from Equation 3, we have with probability at least (1 âˆ’ ğ›¿)</p><formula xml:id="formula_15">(1 âˆ’ ğœ–)FracCov t (U, F) â‰¤ Out 1 Out 2 â‰¤ (1 + ğœ–)FracCov t (U, F).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Counting the Coverage of a Test Suit</head><p>The intuition behind the ApproxCov is similar to the Monte-Carlo method. Given a set of variables ğ‘‹ = {ğ‘¥ 1 , . all possible ğ‘¡-wise coverage tuples (the set with all combinations of size ğ‘¡ that can be obtained with variables from ğ‘‹ ). The algorithm picks a set S of size â„“ of random ğ‘¡-wise coverage tuples from Î© (â„“ is appropriately chosen based on the input parameters). Then it counts the number of elements from S that is realizable by at least one of the tests in U (membership in Cov t (U)). Let this number be ğ‘š. Then the output of the algorithm is ğ‘š â„“ â€¢ |Î©|. In detail, ApproxCov shown in Algorithm 1 starts by setting the size of sample set that it would be picking depending on the parameters ğœ€ and ğ›¿. In the For loop between line 3 and line 7 we pick â„“ samples uniformly at random from Î©. The sampling is done in two steps. For each sample, at first we select uniformly ğ‘¡ variables to be used in a sample at line 4. At the second step we select a value for each variable at random at line 5. Note that this procedure gives a random element of Î© as the universe set can also be written as</p><formula xml:id="formula_16">Î© = ğ‘¤ âˆˆ ğ‘– âˆˆğ‘‡ {ğ‘¥ ğ‘– , Â¬ğ‘¥ ğ‘– } ğ‘‡ âŠ† [ğ‘›] ğ‘¡ ,</formula><p>where [ğ‘›]  ğ‘¡ is the set of all subsets of the set {1, . . . , ğ‘›} of size ğ‘¡. Samples are stored in a map M, where the values indicate whether the sample is realizable by at least one test in U, initialized to 0. Note that there may be some elements that are picked multiple times. In that case we will keep all the copies in the map M, in other words, M is actually a multi-map. In the nested for loops between line 8 and line 14 we update values of the map M if a sampled element is a subset of any of the ğœ âˆˆ U. Finally, in line 15 we sum the variables corresponding to the elements in M and output the value multiplied with an appropriate scaling number.  </p><p>Then it will use an approximate projected model counting algorithm (which we call ApproxCount) on G F to output an (ğœ–, ğ›¿) estimate of |Cov t (Sol(F))|. Several algorithms are known for the approximate model counting problem and we discuss the one we use in Section 5. Since the output of ApproxCount is guaranteed to be within  We now present the main idea of the construction of G F . Construction of G F : Intuitively, G F encodes F and all the ğ‘¡-wise coverage tuples contained in Sol(F). Given natural numbers ğ‘› and ğ‘¡, and a Boolean formula F on ğ‘› variables ğ‘‹ = {ğ‘¥ 0 , . . . , ğ‘¥ ğ‘›âˆ’1 }<ref type="foot" target="#foot_5">6</ref> we will define a new Boolean formula G F on ğ‘› + ğ‘¡ âŒˆlog 2 ğ‘›âŒ‰ + ğ‘¡ variables.</p><p>First ğ‘› variables are the variables of ğ¹ . The remaining set of variables ğ‘† can be partitioned into ğ‘¡ + 1 groups: ğ‘Œ 1 , . . . , ğ‘Œ ğ‘¡ of size âŒˆlog 2 ğ‘›âŒ‰ and ğ‘ = {ğ‘§ 1 , . . . , ğ‘§ ğ‘¡ }. Intuitively, ğ‘† encodes a subset of indices {1, â€¢ â€¢ â€¢ , ğ‘›} of size ğ‘¡: ğ‘Œ ğ‘– is a bit-vector that encodes the ğ‘– ğ‘¡â„ integer in the subset and ğ‘§ ğ‘– is its value in ğ‘‹ . To ensure that only elements of Cov t (Sol(F)) can be assigned to the set ğ‘†, we extend the formula F with additional constraints that is encoded in a formula ğ¹ â€² and the formula G F is constructed as a conjunction of ğ¹ and ğ¹ â€² . For a binary string ğ‘¦ ğ‘– of length âŒˆlog 2 ğ‘›âŒ‰, let val(ğ‘¦ ğ‘– ) denote the number encoded by a binary assignment to the variables in ğ‘Œ . ğ¹ â€² is a formula over variable ğ‘Œ âˆª ğ‘ that encodes the following requirements.</p><p>(1) 0 â‰¤ val(ğ‘¦ ğ‘– ) &lt; ğ‘› for all 1 â‰¤ ğ‘– â‰¤ ğ‘¡.</p><p>(2) val(ğ‘¦ ğ‘– ) &lt; val(ğ‘¦ ğ‘–+1 ) for all 1 â‰¤ ğ‘– â‰¤ ğ‘¡ âˆ’ 1. This constraint together with (1) ensures that the tuple âŸ¨ğ‘¦ 1 , â€¢ â€¢ â€¢ , ğ‘¦ ğ‘¡ âŸ© encodes a subset of indices of size ğ‘¡ (same index cannot appear in a combination multiple times and each set can have only one representation). (3) ğ‘¥ val(ğ‘¦ ğ‘– ) = ğ‘§ ğ‘– for all 1 â‰¤ ğ‘– â‰¤ ğ‘¡. This constraint ensures that the binary assignment variables ğ‘Œ âˆªğ‘ encodes a ğ‘¡-wise coverage tuple contained in the assignment to F. With this intuition it is easy to see that the number of different valid assignments to the set ğ‘† = ğ‘Œ âˆª ğ‘ is the desired value |Cov t (Sol(F))|.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">EXPERIMENTS</head><p>In this section we evaluate the precision and efficiency of algorithms ApproxCov and ApproxMaxCov. Both algorithms have been implemented in Python 3. ApproxMaxCov implementation uses a stateof-the-art tool ApproxMC4 <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b58">58,</ref><ref type="bibr" target="#b59">59]</ref> for ApproxCount subroutine (for approximate projected model counting). In the evaluation of the algorithms, we want to validate that the implementation achieves the theoretical results on the estimation accuracy and to compare the performance of the algorithms with the existing approaches. Therefore, we pose the following research questions:</p><p>â€¢ RQ1 and RQ2: Are approximations of ApproxCov and ApproxMaxCov close to the correct values and within the boundary provided by PAC guarantees? â€¢ RQ3 and RQ4: Are ApproxCov and ApproxMaxCov faster and more scalable than the existing approaches? As discussed in Section 4, an estimate of FracCov t (U, F) for a given sample set U and a formula F can be computed with ApproxCov and ApproxMaxCov. Such an estimate informs us of the ğ‘¡-coverage achieved by a given test suite with respect to the maximum possible ğ‘¡-wise coverage subject to the set of constraints F. Evaluation of FracCov t (U, F) is covered by the following research question:</p><p>â€¢ RQ5 Can algorithms ApproxCov and ApproxMaxCov be used to estimate FracCov t (U, F) and provide a close approximation to the correct result?</p><p>As noted earlier, it is well known <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b39">39]</ref> that typically techniques used for binary domains can be scalably lifted to discrete domains. We describe the extensions of ApproxCov and ApproxMaxCov for the general case along with empirical studies in the end of the section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Benchmarks &amp; Experimental Setup</head><p>For the experiments we selected a large number of publicly available feature models from real-world configurable systems that were used in the literature for the evaluation of sampling tools. In particular, we took 123 benchmarks appeared in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b38">38,</ref><ref type="bibr" target="#b52">52,</ref><ref type="bibr" target="#b53">53]</ref>.</p><p>The benchmarks have between 565 and 11254 variables, between 1164 and 62183 clauses, and between 9.7 Ã— 10 13 and 7.7 Ã— 10 417 solutions. Unfortunately, existing approaches are not capable to compute |Cov t (U)| and |Cov t (Sol(F))| for ğ‘¡ â‰¥ 3 on large benchmarks. Therefore, in order to check approximations for ğ‘¡ â‰¥ 3 we have selected smaller benchmarks from <ref type="bibr" target="#b44">[44]</ref>. In particular we have sorted the benchmarks by the number of variables and randomly selected 1 for each value between 10 and 500 providing 111 extra benchmarks. In the remainder of the section we would reference the first 123 benchmarks as 'large' and the last 111 as 'small'. The evaluation of ApproxCov requires sample sets, therefore we generated them with 3 publicly available tools -WAPS <ref type="bibr" target="#b26">[26]</ref>, Quicksampler <ref type="bibr" target="#b20">[20]</ref>, and Baital <ref type="bibr" target="#b2">[3]</ref> -for each of the 234 benchmarks. Each sample set contains 1000 samples. Since Quicksampler can generate unsatisfiable samples that are filtered afterwards, we generated more samples with this tool and selected the first 1000 valid ones. Note that for several benchmarks, even after requesting 100000 samples, Quicksampler output contained less than 1000 valid samples, therefore we did not consider such sample sets in the experiments. Thus, we used 674 sample sets for the experiment. Similarly to the feature models, we would call sample sets originating from the first 123 feature models as 'large' and the remaining would be 'small'.</p><p>All experiments were conducted on a high performance computer cluster, each node consisting of 2xE5-2690v3 CPUs with 2x12 real cores and 96GB of RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Methodology</head><p>The evaluation of ApproxCov is focused on RQ1 and RQ3. In our experiment we used ApproxCov to approximate |Cov t (U)| for ğ‘¡ âˆˆ <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b5">6]</ref> on 674 sample sets described above. We used ğœ€ and ğ›¿ equal to 0.05. ApproxCov computations have been performed 10 times without fixed random seed and in the results we report the mean running time and the worst-case output; i.e. the output farthest from the |Cov t (U)|. For comparison, we have performed the same computations with BLMCov <ref type="bibr" target="#b2">[3]</ref>. The timeout was set to 3600 seconds and the memory limit was set to 4Gb for both the tools.</p><p>The evaluation of ApproxMaxCov is focused on RQ2 and RQ4. In our experiments we approximated |Cov t (Sol(F))| on 234 benchmarks for ğ‘¡ âˆˆ <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b5">6]</ref>. We used ğ›¿ = ğœ€ = 0.05. Similarly to the previous experiment, all computations with ApproxMaxCov have been performed 10 times without fixed random seed. For comparison, we have performed the same computations with BLMMaxCov <ref type="bibr" target="#b2">[3]</ref>. Originally, the timeout was set to 3600 seconds for both tools. Unfortunately, BLMMaxCov is able to compute only 2 'large' benchmarks within this timeout for ğ‘¡ = 2. Therefore, we raised the timeout for BLMMaxCov to 28800 seconds. The memory limit was set to 4Gb.</p><p>For the evaluation of RQ5 we used the results from the two previous experiments: the estimation of FracCov t (U, F) is obtained by dividing the ğ‘– ğ‘¡â„ result of ApproxCov by the ğ‘– ğ‘¡â„ result of ApproxMaxCov on the corresponding feature model. The 10 generated approximations have been compared with the correct values computed with BLMCov and BLMMaxCov. Confidence parameters of FracCov t (U, F) are derived from the selection of ğœ€ and ğ›¿ in the computation of Approx-Cov and ApproxMaxCov: ğ›¿ = 0.0975, ğœ€ = 0.105.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Results for ApproxCov</head><p>In the first experiment we computed |Cov t (U)| with ApproxCov and BLMCov. For ğ‘¡ = 2, ApproxCov have successfully terminated on all sample sets within 25 seconds. BLMCov has timed out on 2 benchmarks. Comparing the computation time for ğ‘¡ = 2 between BLMCov and ApproxCov, BLMCov was faster on sample sets with few variables. Among large sample sets with more than 500 variables, only 3 were faster with BLMCov, while on the rest of the sets ApproxCov was from 2 to 136 times faster. Time comparison is shown Figure <ref type="figure" target="#fig_4">1</ref>; among 3 points on the right border, 2 correspond to timeouts of BLMCov and the remaining corresponds to 3295 seconds for BLMCov. Slower performance on smaller benchmarks is explained by the fact that the number of picked elements depends on the selected ğœ€ and ğ›¿ parameters rather than the number of variables. Note that on the smallest benchmarks the number of combinations to pick is greater than the total number of different combinations. In such cases all combinations are selected and the result is an exact value rather than approximation.  To check the accuracy of ApproxCov approximation, we compared the approximation results with the correct value of |Cov 2 (U)| computed by BLMCov. For each sample set we took the maximal value of ğ‘ğ‘ğ‘  (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ âˆ’ |Cov 2 (U)|)/|Cov 2 (U)| among 10 ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ğ‘  of ApproxCov. Figure <ref type="figure" target="#fig_3">2</ref> shows the histogram of errors, the largest error was 0.0315 which is smaller than selected ğœ€.</p><p>For ğ‘¡ â‰¥ 3, BLMCov has successfully terminated only on few 'small' benchmarks within the given time and memory budget: 292 benchmarks for ğ‘¡ = 3, 76 for ğ‘¡ = 4, 36 for ğ‘¡ = 5, and 22 for ğ‘¡ = 6. In comparison, ApproxCov terminated on all benchmarks within 650 seconds for all ğ‘¡ â‰¤ 6. The execution time for various values of ğ‘¡ is shown in Figure <ref type="figure" target="#fig_6">3</ref>. The approximation accuracy was within PAC guarantees: the largest error was 0.0369. The histogram of errors on benchmarks computed by BLMCov is shown in Figure <ref type="figure" target="#fig_7">4</ref>.</p><p>Our experiment shows that the results of the ApproxCov are close to the |Cov 2 (U)| and within the selected boundary from PAC guarantees, thus answering RQ1. Comparison of execution time allows us to give a positive answer to RQ3: ApproxCov is can compute |Cov t (U)| for ğ‘¡ = 6, while existing method fails on half of the sample sets for ğ‘¡ = 3.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Results for ApproxMaxCov</head><p>ApproxMaxCov have successfully terminated on all benchmarks for ğ‘¡ = 2 within 360 seconds except 1 benchmark that required 1720 seconds. For comparison, BLMMaxCov has successfully terminated only on 2 'large' benchmarks for ğ‘¡ = 2 with 3600 seconds timeout. After raising timeout to 28800 seconds it succeeded on 221 benchmarks out of 234. The speed up factor of ApproxMaxCov on large benchmarks have range between 6 and 86.</p><p>To check the accuracy of ApproxMaxCov approximation, we compared it with Cov 2 (Sol(F)). For each benchmark, we took the maximal value of ğ‘ğ‘ğ‘  (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ âˆ’ |Cov 2 (Sol(F))|)/|Cov 2 (Sol(F)| among 10 ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ğ‘  of ApproxMaxCov. Results for 8 benchmarks are shown in Table <ref type="table" target="#tab_5">2</ref>. Figure <ref type="figure" target="#fig_8">5</ref> shows the histogram of errors, the largest error was 0.0058 which is smaller than selected ğœ€.</p><p>For larger values of ğ‘¡, ApproxMaxCov timed out of 3600 seconds on the largest benchmark for ğ‘¡ â‰¥ 4 and on one more benchmark for ğ‘¡ = 6. Further exploration of these 2 benchmarks showed that ApproxMaxCov can generate all results within 8500 seconds. The execution time for various values of ğ‘¡ is shown in Figure <ref type="figure" target="#fig_10">6</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Benchmark</head><p>Ground     The experiment shows that results computed by ApproxMaxCov are close to Cov t (Sol(F)) and within the selected boundary from PAC guarantees (RQ2). ApproxMaxCov was significantly faster than the existing methods on large benchmarks and was able to output the result on the benchmarks upto ğ‘¡ = 6, where BLMMaxCov timed out on several benchmarks even with a large time budget on ğ‘¡ = 2, thus allowing us to positively answer to RQ4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Approximation of FracCov t (U, F)</head><p>The approximations of FracCov t (U, F) have been obtained by taking pairs of results of ApproxCov and ApproxMaxCov. We report the worst approximation obtained by this method. Results for 15 sample sets are shown in Table <ref type="table" target="#tab_7">3</ref> and the histogram of errors is shown in Figure <ref type="figure" target="#fig_12">8</ref>. The largest error was 0.038 which is smaller than the derived ğœ€.</p><p>This result shows that the approximation of FracCov t (U, F) obtained with ApproxCov and ApproxMaxCov is close to the correct value. Moreover, considering the scalability of both approximation algorithms, the approximation can be computed on all benchmarks except 6 for ğ‘¡ = 6, while existing methods succeeded only on 13, thus positively answering RQ5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6">Extension to the General Case</head><p>In this section we describe how algorithms ApproxCov and Approx-MaxCov can be generalized to arbitrary alphabet size: the case where each feature can take a finite number of values. In the second part of this subsection we provide results for empirical evaluation.  change the number of selected combinations and the final multiplier to ensure that the approximation is within the PAC guarantees. The second change is the uniform selection of combinations in the set taking into account the number of values each feature can take. Indeed, the sampling shall choose a feature with multiple values more often than binary features. The generalization of ApproxMaxCov is re-implemented, as follows: we start with a formula F encoded with Quantifier-Free Bit-Vector logic (QF_BV) representing constraints of the configurable system. The first step is to construct a QF_BV formula G F by extending F with constraints presented in Section 4.2. At the next step the formula G F is converted into CNF. We use the SMT solver z3 with the following tactics: Then(simplify, bit-blast, tseitin-cnf) (Boolean variables are added to keep track of the original variables). In the resulted CNF formula we approximately compute the number of solutions projected to the set ğ‘† with ApproxMC.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6.1">Generalization of</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.6.2">Empirical Results.</head><p>To illustrate that ApproxCov can directly operate on instances without reduction to Boolean values, we experimented with the implementation of ApproxCov for feature models without binarization. Our benchmark suite consisted of 35 feature models and 35 sample sets from <ref type="bibr" target="#b21">[21]</ref>. The feature models have up to 200 variables having between 2 and 6 values. We used the same cluster, ğœ€ = ğ›¿ = 0.05 for both ApproxCov and ApproxMaxCov. For comparison we used slight modifications of BLMCov and BLMMaxCov: the former just needed to be capable to read the new inputs, while in the latter we additionally replaced calls to SAT solver with calls to SMT solver (z3).</p><p>The timeouts were 3600 seconds for BLMCov, ApproxCov, and ApproxMaxCov, and 14400 seconds for BLMMaxCov. Memory limit was 4Gb. Both ApproxCov and ApproxMaxCov have been run 10 times, we report mean time among 10 runs and the furthest result from the exact value computed with BLMCov and BLMMaxCov.   </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.7">Threats to Validity</head><p>Internal Validity. Our algorithms provide an estimation of the result with Probably Approximately Correct guarantees, and several runs may not yield identical results. To mitigate this threat we provide theoretical proofs that bound the potential error, and in the experiments we run each benchmark multiple times. In the obtained results the difference between multiple runs was below 0.06 for ApproxCov and below 0.021 for ApproxMaxCov, and on all benchmarks the worst approximation was always within PAC guarantees interval for both algorithms. External Validity. To mitigate the threat of non-generalizability of our study we have used a large number of benchmarks used before in several prior studies <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b32">32,</ref><ref type="bibr" target="#b38">38,</ref><ref type="bibr" target="#b44">44,</ref><ref type="bibr" target="#b49">49,</ref><ref type="bibr" target="#b53">53]</ref>. These benchmarks cover a wide range in the number of variables, clauses, and configurations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>Scalable and efficient computation of ğ‘¡-wise coverage is of pivotal importance for Combinatorial testing. In this work, we propose algorithms for estimating ğ‘¡-wise coverage for a given set of tests and also for tests sets with a given set of constraints. In particular, we present (1) a scalable Monte-Carlo based framework ApproxCov that is guaranteed to estimate the size of the coverage of for a given set of tests within (1 Â±ğœ€)-factor of the ground truth with probability at least 1 âˆ’ ğ›¿ for given ğœ€ and ğ›¿; (2) a scalable counting-based framework ApproxMaxCov that estimates maximal achievable coverage for a given formula and guarantees it to be within (1 Â± ğœ€)-factor with probability at least 1 âˆ’ ğ›¿ for given ğœ€ and ğ›¿. The approach have been evaluated on a large set of benchmarks involving up to 11000 variables and we have shown that both frameworks can provide highly accurate results even for estimation of 6-wise coverage of features. We also extended the frameworks to also include nonbinary domains. Our work opens the possibility to compare various test set generators with the presented frameworks. An important direction for future work would be to perform an extensive evaluation of the existing test set generators by estimating the maximum achievable ğ‘¡-wise coverage and exploring the possibility to improve them based on the evaluation results.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>4 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Theorem 4 . 1 .</head><label>41</label><figDesc>Let ğ‘‹ = {ğ‘¥ 1 , . . . , ğ‘¥ ğ‘› } be the set of ğ‘› variables and let U be any subset of ğ‘– {ğ‘¥ ğ‘– , Â¬ğ‘¥ ğ‘– }. Then for any positive integer ğ‘¡ and positive real numbers 0 &lt; ğœ–, ğ›¿ &lt; 1, with probability at least (1 âˆ’ ğ›¿) the output of ApproxCov is an (1 Â± ğœ–)-multiplicative approximation Algorithm 1 ApproxCov(U, ğœ–, ğ›¿)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>( 1 Â±Algorithm 2</head><label>12</label><figDesc>ğœ€) of |Sol(G F â†“{S} )| with probability at least (1 âˆ’ ğ›¿), the output of ApproxMaxCov is also between (1 âˆ’ğœ–)|Cov t (Sol(F))| and (1 + ğœ–)|Cov t (Sol(F))|, with probability at least (1 âˆ’ ğ›¿). ApproxMaxCov(ğ¹, ğ‘¡, ğœ€, ğ›¿) 1: (G F , ğ‘†) â† ConstructGFormula(ğ¹ ) 2: ğ‘ â† ApproxCount(G F , ğ‘†, ğœ€, ğ›¿) 3: return ğ‘ Thus the correctness of the algorithm ApproxMaxCov follows once we show that the formula G F (ğ‘‹, ğ‘†) satisfies the condition in Equation 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Lemma 4. 2 .</head><label>2</label><figDesc>|Cov t (Sol(F))| = |Sol(G F â†“{S} )|</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Comparison of execution time of ApproxCov and BLMCov on 674 sample sets for ğ‘¡ = 2. X axis shows BLMCov time in seconds, Y axis shows ApproxCov time in seconds. Red line indicates equal time. Among 3 points at the right border, 2 correspond to timeout of BLMCov and 1 corresponds to 3295 seconds for BLMCov.</figDesc><graphic coords="8,53.80,83.69,257.01,192.75" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Approximation error of ApproxCov for ğ‘¡ = 2 on 672 sample sets computed as ğ‘šğ‘ğ‘¥ (ğ‘ğ‘ğ‘  (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– âˆ’ |Cov 2 ( U) |)/ |Cov 2 ( U) |), where ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– is approximation returned by ApproxCov on the ğ‘– ğ‘¡â„ run. 2 sample sets that timed out with BLMCov are not used in this figure.</figDesc><graphic coords="8,317.96,83.68,248.03,141.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: ApproxCov execution time on 674 sample sets for ğ‘¡ âˆˆ [2, 6]. X axis shows the value of ğ‘¡ , Y axis shows time in seconds.</figDesc><graphic coords="8,317.96,293.19,248.03,141.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Approximation error of ApproxCov for ğ‘¡ âˆˆ [3, 6] on all benchmarks on which BLMCov has successfully terminated -426 elements in total. The error is computed as ğ‘šğ‘ğ‘¥ (ğ‘ğ‘ğ‘  (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– âˆ’ |Cov t ( U) |)/ |Cov t ( U) |), where ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– is approximation returned by ApproxCov on the ğ‘– ğ‘¡â„ run.</figDesc><graphic coords="9,53.80,83.68,248.03,141.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Approximation error of ApproxMaxCov for ğ‘¡ = 2 on 221 benchmarks on which BLMMaxCov terminated. The error is computed as ğ‘šğ‘ğ‘¥ (ğ‘ğ‘ğ‘  (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– âˆ’ |Cov 2 (Sol(F)) |)/ |Cov 2 (Sol(F)) |), where ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– the approximation returned by ApproxMaxCov on ğ‘– ğ‘¡â„ run.</figDesc><graphic coords="9,53.80,293.86,248.03,141.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>|Cov 2 (</head><label>2</label><figDesc>Sol(F)) |. First column shows the benchmark, second and third columns shows |Cov 2 (Sol(F)) | and worst ApproxMaxCov result from 10 runs, and the last column is computed as (ğ‘ğ‘ğ‘  (ğ‘ğ‘œğ‘™ğ‘¢ğ‘šğ‘›3 âˆ’ |Cov 2 (Sol(F)) |)/ |Cov 2 (Sol(F)) |).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: ApproxMaxCov execution time on 234 benchmarks for ğ‘¡ âˆˆ [2, 6]. X axis shows the value of ğ‘¡ , Y axis shows time in seconds. Points on the top border correspond to timeouts.</figDesc><graphic coords="9,317.96,271.44,248.03,141.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Approximation error of ApproxMaxCov for ğ‘¡ âˆˆ [3, 6] on all benchmarks on which BLMMaxCov has successfully terminated -114 elements in total. The error is computed as ğ‘šğ‘ğ‘¥ (ğ‘ğ‘ğ‘  (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– âˆ’ |Cov t (Sol(F)) |)/ |Cov t (Sol(F)) |), where ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– the approximation returned by ApproxMaxCov on ğ‘– ğ‘¡â„ run.</figDesc><graphic coords="9,317.96,456.70,248.03,141.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 8 :</head><label>8</label><figDesc>Figure 8: Approximation error of FracCov t ( U, F) for ğ‘¡ âˆˆ [3, 6] on all benchmarks on which both BLMCov and BLMMaxCov have successfully terminated -952 elements in total. It has been computed as ğ‘šğ‘ğ‘¥ (ğ‘ğ‘ğ‘  (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– âˆ’ FracCov t ( U, F))/FracCov t ( U, F)), where ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– is a quotient of approximations returned by ApproxCov on the ğ‘– ğ‘¡â„ run and of approximation returned by ApproxMaxCov on the ğ‘– ğ‘¡â„ run on the corresponding feature model.</figDesc><graphic coords="10,53.80,83.68,248.03,141.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 9 :</head><label>9</label><figDesc>Figure 9: Comparison of execution time of ApproxCov and BLMCov for ğ‘¡ âˆˆ [2, 6] on sample sets on which BLMCov have successfully terminated -99 points in total. X axis shows BLMCov time in seconds, Y axis shows ApproxCovGeneral time in seconds. Red line indicates equal time.</figDesc><graphic coords="11,53.80,83.69,257.01,192.75" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 10 :</head><label>10</label><figDesc>Figure 10: Approximation error of ApproxCov for ğ‘¡ âˆˆ [2, 6] on 99 sample sets on which BLMCov have successfully terminated. The error is computed as ğ‘šğ‘ğ‘¥ (ğ‘ğ‘ğ‘  (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– âˆ’ |Cov t ( U) |)/ |Cov t ( U) |), where ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– is approximation returned by ApproxCov on the ğ‘– ğ‘¡â„ run.</figDesc><graphic coords="11,53.80,352.36,248.03,141.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: Approximation error of ApproxMaxCov for ğ‘¡ âˆˆ [2, 3] on 40 benchmarks on which BLMMaxCov terminated. The error is computed as ğ‘šğ‘ğ‘¥ (ğ‘ğ‘ğ‘  (ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– âˆ’ |Cov t (Sol(F)) |)/ |Cov t (Sol(F)) |), where ğ‘Ÿğ‘’ğ‘ ğ‘¢ğ‘™ğ‘¡ ğ‘– the approximation returned by ApproxMaxCov on ğ‘– ğ‘¡â„ run.</figDesc><graphic coords="11,317.96,83.68,248.03,141.73" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>scalable Monte Carlo-based algorithm ApproxCov that takes in a test suite U, a coverage parameter ğ‘¡, a tolerance parameter ğœ€, a confidence parameter ğ›¿ as input, and returns an estimate of |Cov t (U)| that is mathematically guaranteed to be within (1Â±ğœ€)-factor of the ground truth with probability at least 1 âˆ’ ğ›¿, where Cov t (U) is the set of all ğ‘¡-wise coverages of elements in U and | â€¢ | is a set cardinality. ApproxCov takes only O (2 ğ‘¡ â€¢ ğ‘¡ log ğ‘›) (for a constant ğœ€ and ğ›¿) space in contrast to the space requirement of O ( ğ‘› ğ‘¡ 2 ğ‘¡ ) for the existing techniques. Therefore, for small ğ‘¡ &lt; 6, we achieve a reduction from ğ‘‚ (ğ‘› ğ‘¡ ) to ğ‘‚ (ğ‘¡ log ğ‘›). The running time of the algorithm is also scalable for instances with parameters that are currently used in practice.(2) A scalable counting-based algorithm ApproxMaxCov that</figDesc><table /><note>takes in formula F, a coverage parameter ğ‘¡, a tolerance parameter ğœ€, and a confidence parameter ğ›¿ as input, and returns an estimate of |Cov t (Sol(F))| that is guaranteed to be within (1 Â± ğœ€)-factor of the ground truth with probability at least 1âˆ’ğ›¿. ApproxMaxCov reduces computation of |Cov t (Sol(F))| to the problem of projected model counting. Our reduction allows us to build on the recent advances in hashing-based paradigm for projected model counting<ref type="bibr" target="#b8">[9,</ref><ref type="bibr" target="#b10">11,</ref><ref type="bibr" target="#b24">24,</ref><ref type="bibr" target="#b59">59</ref>, 60], and we employ state-of-the-art hashing-based approximate model counter ApproxMC4<ref type="bibr" target="#b58">[58]</ref>.(3) We demonstrate the effectiveness of ApproxCov and Approx-MaxCov via implementations in Python 3 and a comprehensive experimental study. We observe that while the current state of the art techniques fail to compute coverage for beyond ğ‘¡ = 2, ApproxCov and ApproxMaxCov can efficiently handle ğ‘¡ âˆˆ {2, 3, 4, 5, 6} (and beyond ğ‘¡ = 6). Furthermore, for ğ‘¡ = 2 on feature models with thousands of features, we observe significant runtime improvement: in particular, ApproxCov achieves from 2 to 136 factor speedup over prior state of the art BLMCov, while ApproxMaxCov achieves from 6 to 86 factor speedup over prior state of the art technique BLMMaxCov. (4) We show generalizations of ApproxCov and ApproxMaxCov</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>However, this does not imply |Cov t (U)| = |ğ‘ˆ | Ã— |ğ‘‹ | ğ‘¡ since |Cov t (ğœ 1 ) âˆª Cov t (ğœ 2 )| is not necessarily equal to |Cov t (ğœ 1 )| + |Cov t (ğœ 2 )| due to non-empty intersection of Cov t (ğœ 1 ) and Cov t (ğœ 2 ).</figDesc><table><row><cell>Also note that, for</cell></row></table><note>ğ‘–{ğ‘¥ ğ‘– , Â¬ğ‘¥ ğ‘– }, the set of all possible configurations|Cov t ( ğ‘– {ğ‘¥ ğ‘– , Â¬ğ‘¥ ğ‘– })| = 2 ğ‘¡ |ğ‘‹ |ğ‘¡ . We will call Cov t ( ğ‘– {ğ‘¥ ğ‘– , Â¬ğ‘¥ ğ‘– }) the universe and denote it by Î©. The above discussion leads to the following observation which is crucial for the proof of correctness of our algorithm.Observation 2.1. For any U â‰  âˆ… over a set of variables ğ‘‹ and any 1</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 1 :</head><label>1</label><figDesc>Coverage for example formula F</figDesc><table><row><cell>4)</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head></head><label></label><figDesc>: â„“ â† 3 2 ğ‘¡ ğœ– 2 ln(2/ğ›¿) 2: Initialise M = âˆ… 3: for ğ‘˜ = 1; ğ‘˜ â‰¤ â„“; ğ‘˜ + + do</figDesc><table><row><cell>4:</cell><cell cols="3">Pick a random ğ‘‡ ğ‘˜ from [ğ‘›] ğ‘¡</cell></row><row><cell>5:</cell><cell cols="3">Pick a random ğ‘¤ ğ‘˜ from</cell><cell>{ğ‘¥ ğ‘– , Â¬ğ‘¥ ğ‘– }</cell></row><row><cell></cell><cell></cell><cell></cell><cell>ğ‘– âˆˆğ‘‡ ğ‘˜</cell></row><row><cell>6:</cell><cell cols="3">Put ğ‘¤ ğ‘˜ â†’ 0 into M</cell></row><row><cell cols="2">7: end for</cell><cell></cell></row><row><cell cols="3">8: for ğœ âˆˆ U do</cell></row><row><cell>9:</cell><cell cols="3">for ğ‘˜ = 1; ğ‘˜ â‰¤ â„“; ğ‘˜ + + do</cell></row><row><cell>10:</cell><cell cols="3">if ğ‘¤ ğ‘˜ âŠ† ğœ then</cell></row><row><cell>11:</cell><cell></cell><cell cols="2">Update M [ğ‘¤ ğ‘˜ ] to 1</cell></row><row><cell>12:</cell><cell cols="2">end if</cell></row><row><cell>13:</cell><cell cols="2">end for</cell></row><row><cell cols="2">14: end for 15: Output</cell><cell>( ğ‘› ğ‘¡ )2 ğ‘¡ â„“</cell><cell>â„“ ğ‘˜=1 M [ğ‘¤</cell></row></table><note>1ğ‘˜ ] of the |Cov t (U)|. That is, with probability at least (1 âˆ’ ğ›¿),(1 âˆ’ ğœ–)|Cov t (U)| â‰¤ ğ‘› ğ‘¡ 2 ğ‘¡ â„“ â„“ ğ‘˜=1 M [ğ‘¤ ğ‘˜ ] â‰¤ (1 + ğœ–)|Cov t (U)|.Moreover, the amount of space needed is ğ‘‚ 3 2 ğ‘¡ ğœ– 2 ln(2/ğ›¿) ğ‘¡ âŒˆlog 2 ğ‘›âŒ‰ and the run time is ğ‘‚ 3 2 ğ‘¡ ğœ– 2 ln(2/ğ›¿) ğ‘¡ âŒˆlog 2 ğ‘›âŒ‰|U| . 4.2 Counting the Coverage with Constraints In this section we present the algorithm ApproxMaxCov for estimating |Cov t (Sol(F))|. Notice that it is not straightforward to use ApproxCov to estimate this quantity as Sol(F) is not given explicitly. Hence we design a new algorithm ApproxMaxCov that uses a projected model counting algorithm on a related formula. It is a two-step algorithm shown in Algorithm 2. For a Boolean formula F on variable set ğ‘‹ , it will first construct a new Boolean formula G F on variable set ğ‘‹ âˆª ğ‘†, where ğ‘† is an additional set of variables, such that |Cov t (Sol(F))| = |Sol(G F â†“{S} )|</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 2 :</head><label>2</label><figDesc>Comparison of ApproxMaxCov approximations with</figDesc><table><row><cell></cell><cell></cell><cell cols="2">Truth ApproxMaxCov Error</cell></row><row><cell>buildroot</cell><cell>621270</cell><cell>622592</cell><cell>0.0021</cell></row><row><cell cols="2">busybox_1_28_0 1965023</cell><cell>1967616</cell><cell>0.0013</cell></row><row><cell>ecos-icse11</cell><cell>2910229</cell><cell>2913280</cell><cell>0.0010</cell></row><row><cell>financial</cell><cell>917150</cell><cell>919040</cell><cell>0.0021</cell></row><row><cell>mpc50</cell><cell>2719748</cell><cell>2713600</cell><cell>0.0023</cell></row><row><cell>phycore</cell><cell>3008140</cell><cell>3015680</cell><cell>0.0025</cell></row><row><cell>psim</cell><cell>2591638</cell><cell>2597888</cell><cell>0.0024</cell></row><row><cell>sleb</cell><cell>2624832</cell><cell>2630656</cell><cell>0.0022</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6"><head></head><label></label><figDesc>Algorithms. The generalization of Approx-Cov requires a few changes in Algorithm 1, yet the general idea of checking inclusion into Cov t (U) of randomly selected combinations remains the same. In particular, in lines 1 and 15 we need to</figDesc><table><row><cell>Benchmark</cell><cell cols="2">Ground Truth Approximation</cell></row><row><cell cols="2">baital_busybox_1_28_0 0.994542</cell><cell>0.993025</cell></row><row><cell cols="2">waps_busybox_1_28_0 0.985651</cell><cell>0.983794</cell></row><row><cell cols="2">quick_busybox_1_28_0 0.253179</cell><cell>0.256468</cell></row><row><cell>baital_ecos-icse11</cell><cell>0.975684</cell><cell>0.975041</cell></row><row><cell>waps_ecos-icse11</cell><cell>0.790062</cell><cell>0.788512</cell></row><row><cell>quick_ecos-icse11</cell><cell>0.282384</cell><cell>0.277069</cell></row><row><cell>baital_mpc50</cell><cell>0.980516</cell><cell>0.974432</cell></row><row><cell>waps_mpc50</cell><cell>0.797631</cell><cell>0.789341</cell></row><row><cell>quick_mpc50</cell><cell>0.538494</cell><cell>0.546906</cell></row><row><cell>baital_phycore</cell><cell>0.965864</cell><cell>0.961093</cell></row><row><cell>waps_phycore</cell><cell>0.774117</cell><cell>0.782127</cell></row><row><cell>quick_phycore</cell><cell>0.513699</cell><cell>0.519799</cell></row><row><cell>baital_psim</cell><cell>0.975527</cell><cell>0.971872</cell></row><row><cell>waps_psim</cell><cell>0.792510</cell><cell>0.785056</cell></row><row><cell>quick_psim</cell><cell>0.494380</cell><cell>0.498117</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7"><head>Table 3 :</head><label>3</label><figDesc>Approximation of FracCov</figDesc><table /><note>2 ( U, F). Confidence parameters are ğ›¿ = 0.0975, ğœ€ = 0.105.</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1" xml:id="foot_0">defined formally in Section</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2" xml:id="foot_1"><ref type="bibr" target="#b1">2</ref> An alternate approach would be to enumerate all the solutions of ğ¹ , but for most formulas of interest, the number of solutions is too large to enumerate.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="3" xml:id="foot_2">https://github.com/meelgroup/approxcov</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_3">While beta version of ApproxMC5 is released; ApproxMC4's developer recommend usage of ApproxMC4</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_4">We use the implementation available at https://github.com/meelgroup/baital</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_5">Choosing {ğ‘¥ 0 , . . . , ğ‘¥ ğ‘›âˆ’1 } instead of {ğ‘¥ 1 , . . . , ğ‘¥ ğ‘› } is for easiness of presentation.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>This work was supported in part by EU H2020 project Serums (826278-SERUMS-H2020-SC1-FA-DTS-2018-2020), by National Science Foundation USA (NSF HDR:TRIPODS-1934884), and by National Research Foundation Singapore under its NRF Fellowship Programme [NRF-NRFFAI1-2019-0004] and AI Singapore Programme [AISG-RP-2018-005]. Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not reflect the views of National Research Foundation, Singapore.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">42 variability bugs in the linux kernel: a qualitative analysis</title>
		<author>
			<persName><forename type="first">Iago</forename><surname>Abal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Claus</forename><surname>Brabrand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrzej</forename><surname>Wasowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 29th ACM/IEEE international conference on Automated software engineering</title>
				<meeting>the 29th ACM/IEEE international conference on Automated software engineering</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="421" to="432" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">IncLing: efficient product-line testing using incremental pairwise sampling</title>
		<author>
			<persName><forename type="first">Mustafa</forename><surname>Al-Hajjaji</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Krieter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>ThÃ¼m</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Malte</forename><surname>Lochau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gunter</forename><surname>Saake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Notices</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="144" to="155" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Baital: an adaptive weighted sampling approach for improved t-wise coverage</title>
		<author>
			<persName><forename type="first">Eduard</forename><surname>Baranov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Axel</forename><surname>Legay</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kuldeep</forename><forename type="middle">S</forename><surname>Meel</surname></persName>
		</author>
		<idno type="DOI">10.1145/3368089.3409744</idno>
		<ptr target="https://doi.org/10.1145/3368089.3409744" />
	</analytic>
	<monogr>
		<title level="m">ESEC/FSE &apos;20: 28th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering</title>
				<imprint>
			<date type="published" when="2020-11-08">2020. November 8-13, 2020</date>
			<biblScope unit="page" from="1114" to="1126" />
		</imprint>
		<respStmt>
			<orgName>Virtual Event, USA</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A survey of variability modeling in industrial practice</title>
		<author>
			<persName><forename type="first">Thorsten</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ralf</forename><surname>Rublack</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Divya</forename><surname>Nair</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Joanne</forename><forename type="middle">M</forename><surname>Atlee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krzysztof</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrzej</forename><surname>Wasowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Seventh International Workshop on Variability Modelling of Software-intensive Systems</title>
				<meeting>the Seventh International Workshop on Variability Modelling of Software-intensive Systems</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A study of variability models and languages in the systems software domain</title>
		<author>
			<persName><forename type="first">Thorsten</forename><surname>Berger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Steven</forename><surname>She</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Lotufo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrzej</forename><surname>Wasowski</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krzysztof</forename><surname>Czarnecki</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="1611" to="1640" />
			<date type="published" when="2013">2013. 2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">A density-based greedy algorithm for higher strength covering arrays. Software Testing, Verification and Reliability</title>
		<author>
			<persName><forename type="first">C</forename><surname>RenÃ©e</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><forename type="middle">J</forename><surname>Bryce</surname></persName>
		</author>
		<author>
			<persName><surname>Colbourn</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009. 2009</date>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="37" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A formal logic approach to constrained combinatorial testing</title>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Calvagna</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Angelo</forename><surname>Gargantini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Automated Reasoning</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="331" to="358" />
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Scalable and Nearly Uniform Generator of SAT Witnesses</title>
		<author>
			<persName><forename type="first">Supratik</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kuldeep</forename><forename type="middle">S</forename><surname>Meel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CAV</title>
				<meeting>of CAV</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="608" to="623" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A Scalable Approximate Model Counter</title>
		<author>
			<persName><forename type="first">Supratik</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kuldeep</forename><forename type="middle">S</forename><surname>Meel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CP</title>
				<meeting>of CP</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="200" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Balancing Scalability and Uniformity in SAT Witness Generator</title>
		<author>
			<persName><forename type="first">Supratik</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kuldeep</forename><forename type="middle">S</forename><surname>Meel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of DAC</title>
				<meeting>of DAC</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1" to="6" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Algorithmic Improvements in Approximate Counting for Probabilistic Inference: From Linear to Logarithmic SAT Calls</title>
		<author>
			<persName><forename type="first">Supratik</forename><surname>Chakraborty</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kuldeep</forename><forename type="middle">S</forename><surname>Meel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Moshe</forename><forename type="middle">Y</forename><surname>Vardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IJCAI</title>
				<meeting>of IJCAI</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<author>
			<persName><forename type="first">Tsong</forename><surname>Yueh Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hing</forename><surname>Leung</surname></persName>
		</author>
		<author>
			<persName><surname>Mak</surname></persName>
		</author>
		<title level="m">Annual Asian Computing Science Conference</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004">2004</date>
			<biblScope unit="page" from="320" to="329" />
		</imprint>
	</monogr>
	<note>Adaptive random testing</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient and effective testing of automotive software product lines</title>
		<author>
			<persName><forename type="first">Anastasia</forename><surname>Cmyrev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ralf</forename><surname>Reissing</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Applied Science and Technology</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="53" to="57" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
	<note>King Mongkuts University of Technology North Bangkok</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The AETG system: An approach to testing based on combinatorial design</title>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">M</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Siddhartha</forename><forename type="middle">R</forename><surname>Dalal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Michael</forename><forename type="middle">L</forename><surname>Fredman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gardner</forename><forename type="middle">C</forename><surname>Patton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="437" to="444" />
			<date type="published" when="1997">1997. 1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title/>
		<author>
			<persName><forename type="first">Myra</forename><forename type="middle">B</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><forename type="middle">B</forename><surname>Gibbons</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Warwick</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Charles</forename><forename type="middle">J</forename><surname>Mugridge</surname></persName>
		</author>
		<author>
			<persName><surname>Colbourn</surname></persName>
		</author>
		<imprint/>
	</monogr>
	<note>n.d.</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Constructing Test Suites for Interaction Testing</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th International Conference on Software Engineering</title>
				<meeting>the 25th International Conference on Software Engineering<address><addrLine>Portland, Oregon, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003">May 3-10, 2003</date>
			<biblScope unit="page" from="38" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Generating Random Solutions for Constraint Satisfaction Problems</title>
		<author>
			<persName><forename type="first">R</forename><surname>Dechter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Kask</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Emek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of AAAI/IAAI</title>
				<meeting>of AAAI/IAAI</meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="15" to="21" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An evaluation of random testing</title>
		<author>
			<persName><forename type="first">Joe</forename><forename type="middle">W</forename><surname>Duran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Simeon</forename><forename type="middle">C</forename><surname>Ntafos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="438" to="444" />
			<date type="published" when="1984">1984. 1984</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Subtractive reductions and complete problems for counting complexity classes</title>
		<author>
			<persName><forename type="first">Arnaud</forename><surname>Durand</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Miki</forename><surname>Hermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Phokion</forename><forename type="middle">G</forename><surname>Kolaitis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">340</biblScope>
			<biblScope unit="page" from="496" to="513" />
			<date type="published" when="2005">2005. 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Efficient sampling of SAT solutions for testing</title>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Dutra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Laeufer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="549" to="559" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Efficient sampling of SAT solutions for testing</title>
		<author>
			<persName><forename type="first">Rafael</forename><surname>Dutra</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kevin</forename><surname>Laeufer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jonathan</forename><surname>Bachrach</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICSE</title>
				<meeting>of ICSE</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="549" to="559" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">An improved meta-heuristic search for constrained interaction testing</title>
		<author>
			<persName><forename type="first">Myra</forename><forename type="middle">B</forename><surname>Brady J Garvin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Matthew</forename><forename type="middle">B</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><surname>Dwyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2009 1st International Symposium on Search Based Software Engineering</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="13" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">A New Algorithm for Sampling CSP Solutions Uniformly at Random</title>
		<author>
			<persName><forename type="first">V</forename><surname>Gogate</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Dechter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CP</title>
				<meeting>of CP</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="711" to="715" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Model counting: A new strategy for obtaining good bounds</title>
		<author>
			<persName><forename type="first">Carla</forename><forename type="middle">P</forename><surname>Gomes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Sabharwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bart</forename><surname>Selman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of AAAI</title>
				<meeting>of AAAI</meeting>
		<imprint>
			<date type="published" when="2006">2006</date>
			<biblScope unit="page" from="54" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Near-Uniform sampling of combinatorial spaces using XOR constraints</title>
		<author>
			<persName><forename type="first">Carla</forename><forename type="middle">P</forename><surname>Gomes</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ashish</forename><surname>Sabharwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bart</forename><surname>Selman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of NIPS</title>
				<meeting>of NIPS</meeting>
		<imprint>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="670" to="676" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Construction of mixed covering arrays of variable strength using a tabu search approach</title>
		<author>
			<persName><forename type="first">Loreto</forename><surname>Gonzalez-Hernandez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nelson</forename><surname>Rangel-Valdez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jose</forename><surname>Torres</surname></persName>
		</author>
		<author>
			<persName><forename type="first">-Jimenez</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Combinatorial Optimization and Applications</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="51" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">WAPS: Weighted and Projected Sampling</title>
		<author>
			<persName><forename type="first">Rahul</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Shubham</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Subhajit</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kuldeep</forename><forename type="middle">S</forename><surname>Meel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</title>
				<meeting>Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Learning Combinatorial Interaction Test Generation Strategies Using Hyperheuristic Search</title>
		<author>
			<persName><forename type="first">Yue</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Myra</forename><forename type="middle">B</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Harman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Justyna</forename><surname>Petke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">37th IEEE/ACM International Conference on Software Engineering, ICSE 2015</title>
				<meeting><address><addrLine>Florence, Italy</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2015-05-16">2015. May 16-24, 2015</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="540" to="550" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">An algorithm for generating t-wise covering arrays from large feature models</title>
		<author>
			<persName><forename type="first">Martin</forename><surname>Fagereng Johansen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ã˜ystein</forename><surname>Haugen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Franck</forename><surname>Fleurey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Software Product Line Conference</title>
				<meeting>the 16th International Software Product Line Conference</meeting>
		<imprint>
			<date type="published" when="2012">2012</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="46" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Monte-Carlo algorithms for enumeration and reliability problems</title>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">M</forename><surname>Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Luby</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of FOCS</title>
				<meeting>of FOCS</meeting>
		<imprint>
			<date type="published" when="1983">1983. 1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Monte-Carlo Approximation Algorithms for Enumeration Problems</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Richard M Karp</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Neal</forename><surname>Luby</surname></persName>
		</author>
		<author>
			<persName><surname>Madras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Algorithms</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="429" to="448" />
			<date type="published" when="1989">1989. 1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<title level="m" type="main">Markov Chain Monte Carlo stimulus generation for constrained random simulation</title>
		<author>
			<persName><forename type="first">Nathan</forename><surname>Kitchen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010">2010</date>
			<publisher>Ph.D. Dissertation. UC Berkeley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Is there a mismatch between real-world feature models and product-line research</title>
		<author>
			<persName><forename type="first">Alexander</forename><surname>KnÃ¼ppel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>ThÃ¼m</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Mennicke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jens</forename><surname>Meinicke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ina</forename><surname>Schaefer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering</title>
				<meeting>the 2017 11th Joint Meeting on Foundations of Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="291" to="302" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Practical combinatorial testing</title>
		<author>
			<persName><forename type="first">Raghu</forename><forename type="middle">N</forename><surname>Richard Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Kacker</surname></persName>
		</author>
		<author>
			<persName><surname>Lei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">NIST special Publication</title>
		<imprint>
			<biblScope unit="volume">800</biblScope>
			<biblScope unit="page">142</biblScope>
			<date type="published" when="2010">2010. 2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<monogr>
		<title level="m" type="main">Introduction to combinatorial testing</title>
		<author>
			<persName><forename type="first">Raghu</forename><forename type="middle">N</forename><surname>Richard Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yu</forename><surname>Kacker</surname></persName>
		</author>
		<author>
			<persName><surname>Lei</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
			<publisher>CRC press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Building circuits from relations</title>
		<author>
			<persName><forename type="first">H</forename><surname>James</surname></persName>
		</author>
		<author>
			<persName><surname>Kukula</surname></persName>
		</author>
		<author>
			<persName><surname>Thomas R Shiple</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of CAV</title>
				<meeting>of CAV</meeting>
		<imprint>
			<date type="published" when="2000">2000</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">IPOG: A general strategy for t-way software testing</title>
		<author>
			<persName><forename type="first">Yu</forename><surname>Lei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raghu</forename><surname>Kacker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vadim</forename><surname>Okun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Lawrence</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">14th Annual IEEE International Conference and Workshops on the Engineering of Computer-Based Systems (ECBS&apos;07)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2007">2007</date>
			<biblScope unit="page" from="549" to="556" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<author>
			<persName><forename type="first">Yu</forename><surname>Lei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raghu</forename><surname>Kacker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Richard</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vadim</forename><surname>Okun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">James</forename><surname>Lawrence</surname></persName>
		</author>
		<title level="m">IPOG/IPOG-D: efficient test generation for multi-way combinatorial testing. Software Testing, Verification and Reliability</title>
				<imprint>
			<date type="published" when="2008">2008. 2008</date>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="125" to="148" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Sat-based analysis of large real-world feature models is easy</title>
		<author>
			<persName><forename type="first">Jia</forename><surname>Hui Liang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Vijay</forename><surname>Ganesh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krzysztof</forename><surname>Czarnecki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Venkatesh</forename><surname>Raman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 19th International Conference on Software Product Line</title>
				<meeting>the 19th International Conference on Software Product Line</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="91" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<monogr>
		<title level="m" type="main">LS-Sampling: An Effective Local Search Based Sampling Approach for Achieving High t-Wise Coverage</title>
		<author>
			<persName><forename type="first">Chuan</forename><surname>Luo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Binqi</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bo</forename><surname>Qiao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Junjie</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hongyu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinkun</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qingwei</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongmei</forename><surname>Zhang</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2021">2021. 2021</date>
			<biblScope unit="page" from="1081" to="1092" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Orthogonal Latin squares: an application of experiment design to compiler testing</title>
		<author>
			<persName><forename type="first">Robert</forename><surname>Mandl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1054" to="1058" />
			<date type="published" when="1985">1985. 1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Practical pairwise testing for software product lines</title>
		<author>
			<persName><forename type="first">Dusica</forename><surname>Marijan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Arnaud</forename><surname>Gotlieb</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sagar</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aymeric</forename><surname>Hervieu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th international software product line conference</title>
				<meeting>the 17th international software product line conference</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="227" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Generation of pairwise test sets using a genetic algorithm</title>
		<author>
			<persName><forename type="first">D</forename><surname>James</surname></persName>
		</author>
		<author>
			<persName><surname>Mccaffrey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2009 33rd annual IEEE international computer software and applications conference</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="626" to="631" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A comparison of 10 sampling algorithms for configurable systems</title>
		<author>
			<persName><forename type="first">FlÃ¡vio</forename><surname>Medeiros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>KÃ¤stner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">MÃ¡rcio</forename><surname>Ribeiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rohit</forename><surname>Gheyi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sven</forename><surname>Apel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2016 IEEE/ACM 38th International Conference on Software Engineering (ICSE)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="643" to="654" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Model counting and uniform sampling instances</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kuldeep</surname></persName>
		</author>
		<author>
			<persName><surname>Meel</surname></persName>
		</author>
		<idno type="DOI">https:/doi.org/10.5281/zenodo.3793090</idno>
		<ptr target="https://doi.org/https:/doi.org/10.5281/zenodo.3793090" />
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Sparse hashing for scalable approximate model counting: Theory and practice</title>
		<author>
			<persName><forename type="first">S</forename><surname>Kuldeep</surname></persName>
		</author>
		<author>
			<persName><forename type="first">S</forename><surname>Meel</surname></persName>
		</author>
		<author>
			<persName><surname>Akshay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of LICS</title>
				<meeting>of LICS</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Chaff: Engineering an efficient SAT solver</title>
		<author>
			<persName><surname>Matthew W Moskewicz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ying</forename><surname>Conor F Madigan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lintao</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sharad</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><surname>Malik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of DAC</title>
				<meeting>of DAC</meeting>
		<imprint>
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">A survey of combinatorial testing</title>
		<author>
			<persName><forename type="first">Changhai</forename><surname>Nie</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Hareton</forename><surname>Leung</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys (CSUR)</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="1" to="29" />
			<date type="published" when="2011">2011. 2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">Upper bounds for covering arrays by tabu search</title>
		<author>
			<persName><forename type="first">Kari</forename><forename type="middle">J</forename><surname>Nurmela</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete applied mathematics</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="page" from="143" to="152" />
			<date type="published" when="2004">2004. 2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">2019. t-wise coverage by uniform sampling</title>
		<author>
			<persName><forename type="first">Jeho</forename><surname>Oh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paul</forename><surname>Gazzillo</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Don</forename><forename type="middle">S</forename><surname>Batory</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Systems and Software Product Line Conference, SPLC 2019</title>
				<meeting>the 23rd International Systems and Software Product Line Conference, SPLC 2019<address><addrLine>Paris, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2019">September 9-13, 2019</date>
			<biblScope unit="volume">A</biblScope>
			<biblScope unit="page">4</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">On the design and development of program families</title>
		<author>
			<persName><forename type="first">David</forename><surname>Lorge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Parnas</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on software engineering</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1" to="9" />
			<date type="published" when="1976">1976. 1976</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Automated and scalable t-wise test case generation strategies for software product lines</title>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Perrouin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sagar</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jacques</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Benoit</forename><surname>Baudry</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yves</forename><surname>Le Traon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 Third international conference on software testing, verification and validation</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2010">2010</date>
			<biblScope unit="page" from="459" to="468" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<monogr>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Pett</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Thomas</forename><surname>ThÃ¼m</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tobias</forename><surname>Runge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sebastian</forename><surname>Krieter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Malte</forename><surname>Lochau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ina</forename><surname>Schaefer</surname></persName>
		</author>
		<title level="m">Product Sampling for Product Lines: The Scalability Challenge</title>
				<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">Uniform sampling of sat solutions for configurable systems: Are we there yet?</title>
		<author>
			<persName><forename type="first">Quentin</forename><surname>Plazar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mathieu</forename><surname>Acher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gilles</forename><surname>Perrouin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xavier</forename><surname>Devroey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Maxime</forename><surname>Cordy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 12th IEEE Conference on Software Testing, Validation and Verification (ICST)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="240" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<analytic>
		<title level="a" type="main">Assessing fine-grained feature dependencies</title>
		<author>
			<persName><forename type="first">Iran</forename><surname>Rodrigues</surname></persName>
		</author>
		<author>
			<persName><forename type="first">MÃ¡rcio</forename><surname>Ribeiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">FlÃ¡vio</forename><surname>Medeiros</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Paulo</forename><surname>Borba</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Baldoino</forename><surname>Fonseca</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rohit</forename><surname>Gheyi</surname></persName>
		</author>
		<idno type="DOI">10.1016/j.infsof.2016.05.006</idno>
		<ptr target="https://doi.org/10.1016/j.infsof.2016.05.006" />
	</analytic>
	<monogr>
		<title level="j">Inf. Softw. Technol</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page" from="27" to="52" />
			<date type="published" when="2016">2016. 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Vector sets for exhaustive testing of logic circuits</title>
		<author>
			<persName><forename type="first">Gadiel</forename><surname>Seroussi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Nader</surname></persName>
		</author>
		<author>
			<persName><surname>Bshouty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Information Theory</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="513" to="522" />
			<date type="published" when="1988">1988. 1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<analytic>
		<title level="a" type="main">Knowledge Compilation meets Uniform Sampling</title>
		<author>
			<persName><forename type="first">Shubham</forename><surname>Sharma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rahul</forename><surname>Gupta</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Subhajit</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kuldeep</forename><forename type="middle">S</forename><surname>Meel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of LPAR-22</title>
				<meeting>of LPAR-22</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="620" to="636" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Covering arrays and intersecting codes</title>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Neil</surname></persName>
		</author>
		<author>
			<persName><surname>Sloane</surname></persName>
		</author>
		<idno type="DOI">10.1002/jcd.3180010106</idno>
		<ptr target="https://doi.org/10.1002/jcd.3180010106" />
	</analytic>
	<monogr>
		<title level="j">Journal of combinatorial designs</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="51" to="63" />
			<date type="published" when="1993">1993. 1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">Tinted, Detached, and Lazy CNF-XOR solving and its Applications to Counting and Sampling</title>
		<author>
			<persName><forename type="first">Mate</forename><surname>Soos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Stephan</forename><surname>Gocht</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kuldeep</forename><forename type="middle">S</forename><surname>Meel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Aided Verification (CAV)</title>
				<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<analytic>
		<title level="a" type="main">BIRD: Engineering an Efficient CNF-XOR SAT Solver and its Applications to Approximate Model Counting</title>
		<author>
			<persName><forename type="first">Mate</forename><surname>Soos</surname></persName>
		</author>
		<author>
			<persName><surname>Kuldeep</surname></persName>
		</author>
		<author>
			<persName><surname>Meel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of AAAI</title>
				<meeting>of AAAI</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<analytic>
		<title level="a" type="main">The complexity of approximate counting</title>
		<author>
			<persName><forename type="first">Larry</forename><surname>Stockmeyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of STOC</title>
				<meeting>of STOC</meeting>
		<imprint>
			<date type="published" when="1983">1983</date>
			<biblScope unit="page" from="118" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b61">
	<analytic>
		<title level="a" type="main">Configuration coverage in the analysis of large-scale system software</title>
		<author>
			<persName><forename type="first">Reinhard</forename><surname>Tartler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Daniel</forename><surname>Lohmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>Dietrich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christoph</forename><surname>Egger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julio</forename><surname>Sincero</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Workshop on Programming Languages and Operating Systems</title>
				<meeting>the 6th Workshop on Programming Languages and Operating Systems</meeting>
		<imprint>
			<date type="published" when="2011">2011</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b62">
	<analytic>
		<title level="a" type="main">Test case design support system</title>
		<author>
			<persName><forename type="first">Keizo</forename><surname>Tatsumi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. International Conference on Quality Control (ICQC&apos;87)</title>
				<meeting>International Conference on Quality Control (ICQC&apos;87)</meeting>
		<imprint>
			<date type="published" when="1987">1987</date>
			<biblScope unit="page" from="615" to="620" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b63">
	<analytic>
		<title level="a" type="main">A classification and survey of analysis strategies for software product lines</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>ThÃ¼m</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sven</forename><surname>Apel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christian</forename><surname>KÃ¤stner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ina</forename><surname>Schaefer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gunter</forename><surname>Saake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computing Surveys (CSUR)</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="1" to="45" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b64">
	<analytic>
		<title level="a" type="main">The complexity of enumeration and reliability problems</title>
		<author>
			<persName><forename type="first">Leslie</forename><forename type="middle">G</forename><surname>Valiant</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="410" to="421" />
			<date type="published" when="1979">1979. 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b65">
	<analytic>
		<title level="a" type="main">Greedy heuristic algorithms to generate variable strength combinatorial test suite</title>
		<author>
			<persName><forename type="first">Ziyuan</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Baowen</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Changhai</forename><surname>Nie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2008 The Eighth International Conference on Quality Software</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008">2008</date>
			<biblScope unit="page" from="155" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b66">
	<analytic>
		<title level="a" type="main">A new approach to model counting</title>
		<author>
			<persName><forename type="first">Wei</forename><surname>Wei</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bart</forename><surname>Selman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of SAT</title>
				<meeting>of SAT</meeting>
		<imprint>
			<date type="published" when="2005">2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b67">
	<analytic>
		<title level="a" type="main">Greedy combinatorial test case generation using unsatisfiable cores</title>
		<author>
			<persName><forename type="first">Akihisa</forename><surname>Yamada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Armin</forename><surname>Biere</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cyrille</forename><surname>Artho</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Takashi</forename><surname>Kitamura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eun-Hye</forename><surname>Choi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering</title>
				<meeting>the 31st IEEE/ACM International Conference on Automated Software Engineering</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="614" to="624" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b68">
	<analytic>
		<title level="a" type="main">Moving Forward with Combinatorial Interaction Testing</title>
		<author>
			<persName><forename type="first">Cemal</forename><surname>Yilmaz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sandro</forename><surname>FouchÃ©</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Myra</forename><forename type="middle">B</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adam</forename><forename type="middle">A</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName><forename type="first">GÃ¼lsen</forename><surname>DemirÃ¶z</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ugur</forename><surname>Koc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="37" to="45" />
			<date type="published" when="2014">2014. 2014</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
